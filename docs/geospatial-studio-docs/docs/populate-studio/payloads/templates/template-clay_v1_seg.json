{
    "name": "clay_v1 : Segmentation",
    "description": "Segmentation of the clay backbone models",
    "purpose": "Segmentation",
    "model_params": {
        "$uri": "https://ibm.com/watsonx.ai.geospatial.finetune.segmentation.clay.json",
        "type": "object",
        "title": "Finetune",
        "$schema": "https://json-schema.org/draft/2020-12/schema",
        "properties": {
            "data": {
            "type": "object",
            "default": {
                "batch_size": 4,
                "constant_multiply": 1,
                "workers_per_gpu": 2
            },
            "properties": {
                "batch_size": {
                "type": "int",
                "default": 4,
                "description": "Batch size",
                "studio_name": "Batch size"
                },
                "constant_multiply": {
                "type": "float",
                "default": 1,
                "description": "Constant Scale",
                "studio_name": "Constant Scale"
                },
                "workers_per_gpu": {
                "studio_name": "Workers per GPU",
                "description": "Workers per GPU",
                "type": "int",
                "default": 2
                }
            },
            "studio_name": "Data loading"
            },
            "model": {
            "type": "object",
            "default": {
                "decode_head": {
                "channels": 256,
                "num_convs": 4,
                "decoder": "UNetDecoder",
                "loss_decode": {
                    "type": "CrossEntropyLoss",
                    "avg_non_ignore": true
                }
                },
                "frozen_backbone": false,
                "tiled_inference_parameters": {
                "h_crop": 512,
                "h_stride": 448,
                "w_crop": 512,
                "w_stride": 448,
                "average_patches": true
                },
                "backbone_img_size": 512
            },
            "properties": {
                "decode_head": {
                "type": "object",
                "default": {
                    "channels": 256,
                    "num_convs": 4,
                    "decoder": "UperNetDecoder",
                    "loss_decode": {
                    "type": "CrossEntropyLoss",
                    "avg_non_ignore": true
                    }
                },
                "properties": {
                    "channels": {
                    "type": "int",
                    "default": 256,
                    "description": "Channels at each block of the decode head, except the final one",
                    "studio_name": "Channels"
                    },
                    "num_convs": {
                    "type": "int",
                    "default": 4,
                    "description": "Number of convolutional blocks in the head (except the final one)",
                    "studio_name": "Blocks"
                    },
                    "decoder": {
                    "enum": [
                        "UperNetDecoder",
                        "UNetDecoder"
                    ],
                    "type": "string",
                    "default": "Fixed",
                    "description": "Decoder type",
                    "studio_name": "Decoder type"
                    },
                    "loss_decode": {
                    "type": "object",
                    "properties": {
                        "type": {
                        "enum": [
                            "CrossEntropyLoss"
                        ],
                        "type": "string",
                        "default": "CrossEntropyLoss",
                        "description": "Type of loss function",
                        "studio_name": "Loss function"
                        },
                        "avg_non_ignore": {
                        "type": "bool",
                        "default": true,
                        "description": "The loss is only averaged over non-ignored targets (ignored targets are usually where labels are missing in the dataset) if this is True"
                        }
                    },
                    "description": "Loss function to be used",
                    "studio_name": "Loss"
                    }
                },
                "description": "Architecture of the decode head",
                "studio_name": "Head"
                },
                "auxiliary_head": {
                "type": "object",
                "default": {},
                "properties": {
                    "decoder": {
                    "type": "string",
                    "default": "FCNDecoder",
                    "description": "Decoder function to use",
                    "studio_name": "Decoder"
                    },
                    "channels": {
                    "type": "int",
                    "default": 256,
                    "description": "Channels at each block of the decode head, except the final one",
                    "studio_name": "Channels"
                    },
                    "num_convs": {
                    "type": "int",
                    "default": 2,
                    "description": "Number of convolutional blocks in the head (except the final one)",
                    "studio_name": "Blocks"
                    },
                    "in_index": {
                    "type": "int",
                    "default": -1,
                    "description": "Index of the input list to take. Defaults to -1",
                    "studio_name": "In index"
                    },
                    "dropout": {
                    "type": "int",
                    "default": 0,
                    "description": "Dropout value to apply. Defaults to 0",
                    "studio_name": "Dropout"
                    },
                    "loss_decode": {
                    "type": "object",
                    "properties": {
                        "type": {
                        "enum": [
                            "CrossEntropyLoss"
                        ],
                        "type": "string",
                        "default": "CrossEntropyLoss",
                        "description": "Type of loss function",
                        "studio_name": "Loss function"
                        },
                        "loss_weight": {
                        "type": "float",
                        "default": 1,
                        "description": "Multiplicative weight of the loss of the auxiliary head in the loss. The loss is calculated as aux_head_weight * aux_head_loss + decode_head_loss",
                        "studio_name": "Loss weight"
                        },
                        "avg_non_ignore": {
                        "type": "bool",
                        "default": true,
                        "description": "The loss is only averaged over non-ignored targets (ignored targets are usually where labels are missing in the dataset) if this is True"
                        }
                    },
                    "description": "Loss function to be used",
                    "studio_name": "Loss"
                    }
                },
                "description": "Architecture of the auxiliary head"
                },
                "frozen_backbone": {
                "type": "bool",
                "default": false,
                "description": "Freeze the weights of the backbone when set to True",
                "studio_name": "Freeze backbone"
                },
                "tiled_inference_parameters": {
                "type": "object",
                "default": {
                    "h_crop": 512,
                    "h_stride": 448,
                    "w_crop": 512,
                    "w_stride": 448,
                    "average_patches": true
                },
                "properties": {
                    "h_crop": {
                    "type": "int",
                    "default": 512,
                    "description": "h_crop values for tilling images",
                    "studio_name": "h_crop"
                    },
                    "h_stride": {
                    "type": "int",
                    "default": 448,
                    "description": "h_stride values for tilling images",
                    "studio_name": "h_stride"
                    },
                    "w_crop": {
                    "type": "int",
                    "default": 512,
                    "description": "w_crop values for tilling images",
                    "studio_name": "w_crop"
                    },
                    "w_stride": {
                    "type": "int",
                    "default": 448,
                    "description": "w_stride values for tilling images",
                    "studio_name": "w_stride"
                    },
                    "average_patches": {
                    "type": "bool",
                    "default": true,
                    "description": "Whether to use average_patches",
                    "studio_name": "average_patches"
                    }
                }
                },
                "backbone_img_size": {
                "type": "int",
                "default": 512,
                "description": "Backbone image size for specific models i.e Clay",
                "studio_name": "Backbone image size"
                }
            },
            "description": "Model architecture definition",
            "studio_name": "Architecture"
            },
            "runner": {
            "type": "object",
            "default": {
                "max_epochs": 10,
                "early_stopping_patience": 20,
                "early_stopping_monitor": "val/loss"
            },
            "properties": {
                "max_epochs": {
                "type": "int",
                "default": 10,
                "description": "Training epochs",
                "studio_name": "Training epochs"
                },
                "early_stopping_patience": {
                "type": "int",
                "default": 20,
                "description": "Early stopping patience",
                "studio_name": "Early stopping patience"
                },
                "early_stopping_monitor": {
                "type": "string",
                "default": "val/loss",
                "description": "Monitoring value to determine early stopping",
                "studio_name": "Early stopping monitor"
                }
            },
            "studio_name": "Runner"
            },
            "lr_config": {
            "type": "object",
            "default": {
                "policy": "Fixed"
            },
            "required": [
                "policy"
            ],
            "properties": {
                "policy": {
                "enum": [
                    "Fixed",
                    "CosineAnnealing"
                ],
                "type": "string",
                "default": "Fixed",
                "description": "Policy type",
                "studio_name": "Policy type"
                },
                "warmup_iters": {
                "type": "int",
                "default": 0,
                "description": "LR warmup iterations. Valid for some policies",
                "studio_name": "Learning rate warmup iterations"
                },
                "warmup_ratio": {
                "type": "float",
                "default": 1,
                "description": "Initial lr at warmup will be learning_rate * warmup_ratio",
                "studio_name": "LR warmup initialization ratio"
                }
            },
            "description": "Learning rate policy",
            "studio_name": "Learning rate policy"
            },
            "optimizer": {
                "type": "object",
                "default": {
                    "lr": 0.00006,
                    "type": "Adam"
                },
                "properties": {
                    "lr": {
                    "type": "float",
                    "default": 0.00006,
                    "description": "Learning rate",
                    "studio_name": "Learning rate"
                    },
                    "type": {
                    "enum": [
                        "Adam",
                        "SGD",
                        "AdamW",
                        "RMSProp"
                    ],
                    "default": "Adam",
                    "description": "Optimizer to be used",
                    "studio_name": "Optimizer type"
                    },
                    "weight_decay": {
                    "type": "float",
                    "default": 0,
                    "description": "L2 weight regularization (weight decay)",
                    "studio_name": "L2 regularization weight"
                    }
                },
                "description": "Optimizer",
                "studio_name": "Optimizer"
            },
            "dataset_id": {
                "type": "string",
                "description": "ID of dataset to use for this finetuning",
                "studio_name": "Dataset"
            },
            "evaluation": {
                "type": "object",
                "default": {
                    "interval": 1
                },
                "properties": {
                    "interval": {
                        "type": "int",
                        "default": 1,
                        "description": "Frequency of epochs with which to perform validation",
                        "studio_name": "Epoch interval"
                    }
                },
                "studio_name": "Validation"
            },
            "backbone_model_id": {
            "type": "string",
            "description": "ID of the pretrained backbone"
            }
        },
        "description": "A request sent to the finetuning service to start a finetune task for clay backbone segmentation"
    },
    "extra_info": {
        "runtime_image": "quay.io/geospatial-studio/geostudio-tt-ubi:latest",
        "model_category": "clay"
    },
    "content": "IyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwojIExpY2Vuc2VkIE1hdGVyaWFscyAtIFByb3BlcnR5IG9mIElCTQojICJSZXN0cmljdGVkIE1hdGVyaWFscyBvZiBJQk0iCiMgQ29weXJpZ2h0IElCTSBDb3JwLiAyMDI1IEFMTCBSSUdIVFMgUkVTRVJWRUQKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwoKCiMgbGlnaHRuaW5nLnB5dG9yY2g9PTIuMS4xCnNlZWRfZXZlcnl0aGluZzogMAp0cmFpbmVyOgogIGFjY2VsZXJhdG9yOiBhdXRvCiAgc3RyYXRlZ3k6IGF1dG8KICBkZXZpY2VzOiBhdXRvCiAgbnVtX25vZGVzOiAxCiAgcHJlY2lzaW9uOiAxNi1taXhlZAogIGVuYWJsZV9wcm9ncmVzc19iYXI6IGZhbHNlCiAgbG9nZ2VyOgogICAgY2xhc3NfcGF0aDogbGlnaHRuaW5nLnB5dG9yY2gubG9nZ2Vycy5tbGZsb3cuTUxGbG93TG9nZ2VyCiAgICBpbml0X2FyZ3M6CiAgICAgIGV4cGVyaW1lbnRfbmFtZToge3sgdHVuZV9pZCB9fSAjIEZ1dHVyZSB2ZXJzaW9uLCBjaG5hZ2UgdGhpcyB0byB1c2VyIC8gZW1haWwKICAgICAgcnVuX25hbWU6ICJUcmFpbiIgICAgIyBGdXR1cmUgdmVyc2lvbiwgY2huYWdlIHRoaXMgdG8gdHVuZV9pZAogICAgICB0cmFja2luZ191cmk6IHt7IG1sZmxvd190cmFja2luZ191cmwgfX0KICAgICAgc2F2ZV9kaXI6IHt7IG1vdW50X3Jvb3QgKyAndHVuZS10YXNrcy8nICsgdHVuZV9pZCArICcvbWxmbG93JyB9fQogICAgICB7JSBpZiBtbGZsb3dfdGFncyAtJX0KICAgICAgdGFnczoKICAgICAgICB7JSBmb3Iga2V5LCB2YWx1ZSBpbiBtbGZsb3dfdGFncy5pdGVtcygpIC0lfQogICAgICAgIHt7IGtleSB9fToge3sgdmFsdWUgfX0KICAgICAgICB7JSBlbmRmb3IgJX0KICAgICAgeyUtIGVuZGlmICV9ICAgICAgIAogIGNhbGxiYWNrczoKICAgIC0gY2xhc3NfcGF0aDogTGVhcm5pbmdSYXRlTW9uaXRvcgogICAgICBpbml0X2FyZ3M6CiAgICAgICAgbG9nZ2luZ19pbnRlcnZhbDogZXBvY2gKICAgICMgLS0tLSBFYXJseSBzdG9wIGlmIC0tLS0KICAgIHslIGlmIHJ1bm5lclsiZWFybHlfc3RvcHBpbmdfcGF0aWVuY2UiXSAtJX0KICAgIC0gY2xhc3NfcGF0aDogRWFybHlTdG9wcGluZwogICAgICBpbml0X2FyZ3M6CiAgICAgICAgbW9uaXRvcjoge3sgcnVubmVyWyJlYXJseV9zdG9wcGluZ19tb25pdG9yIl0gfX0KICAgICAgICBwYXRpZW5jZToge3sgcnVubmVyWyJlYXJseV9zdG9wcGluZ19wYXRpZW5jZSJdIH19CiAgICB7JS0gZW5kaWYgJX0KICAgICAjIC0tLS0gRWFybHkgc3RvcCBlbmRpZiAtLS0tCiAgICAtIGNsYXNzX3BhdGg6IE1vZGVsQ2hlY2twb2ludAogICAgICBpbml0X2FyZ3M6CiAgICAgICAgZGlycGF0aDoge3sgbW91bnRfcm9vdCArICd0dW5lLXRhc2tzLycgKyB0dW5lX2lkICArICcvJyB9fQogICAgICAgIG1vZGU6IG1pbgogICAgICAgIG1vbml0b3I6IHZhbC9sb3NzCiAgICAgICAgZmlsZW5hbWU6IHt7ICdiZXN0LXN0YXRlX2RpY3Qte2Vwb2NoOjAyZH0nIH19CiAgICAgICAgc2F2ZV93ZWlnaHRzX29ubHk6IFRydWUKICAgICAgCiAgbWF4X2Vwb2Noczoge3sgcnVubmVyWyJtYXhfZXBvY2hzIl0gfX0KICBjaGVja192YWxfZXZlcnlfbl9lcG9jaDoge3sgZXZhbHVhdGlvblsiaW50ZXJ2YWwiXSB9fQogIGxvZ19ldmVyeV9uX3N0ZXBzOiA1MAogIGVuYWJsZV9jaGVja3BvaW50aW5nOiB0cnVlCiAgZGVmYXVsdF9yb290X2Rpcjoge3sgbW91bnRfcm9vdCArICd0dW5lLXRhc2tzLycgKyB0dW5lX2lkIH19CgpkYXRhOgogIGNsYXNzX3BhdGg6IHRlcnJhdG9yY2guZGF0YW1vZHVsZXMuR2VuZXJpY05vbkdlb1NlZ21lbnRhdGlvbkRhdGFNb2R1bGUKICBpbml0X2FyZ3M6CiAgICBiYXRjaF9zaXplOiB7eyBkYXRhWyJiYXRjaF9zaXplIl0gfX0KICAgIG51bV93b3JrZXJzOiB7eyBkYXRhWyJ3b3JrZXJzX3Blcl9ncHUiXSB9fQogICAgbm9fbGFiZWxfcmVwbGFjZToge3sgbGFiZWxfbm9kYXRhIH19CiAgICBub19kYXRhX3JlcGxhY2U6IHt7IGltYWdlX25vZGF0YV9yZXBsYWNlIH19CiAgICBjb25zdGFudF9zY2FsZToge3sgY29uc3RhbnRfbXVsdGlwbHkgfX0KICAgIGRhdGFzZXRfYmFuZHM6CiAgICAgIHt7IGJhbmRzLnZhbHVlcygpIHwgbGlzdCB8IGZpcnN0IHwgdG9feWFtbCB8IGluZGVudCg2KSB9fQogICAgb3V0cHV0X2JhbmRzOgogICAgICB7eyBvdXRwdXRfYmFuZHMudmFsdWVzKCkgfCBsaXN0IHwgZmlyc3QgfCB0b195YW1sIHwgaW5kZW50KDYpIH19CiAgICByZ2JfaW5kaWNlczoKICAgICAge3sgcmdiX2JhbmRfaW5kaWNlcyB8IHRvX3lhbWwgfCBpbmRlbnQoNikgfX0KICAgIHRyYWluX2RhdGFfcm9vdDoge3sgZGF0YV9yb290IH19e3sgdHJhaW5fZGF0YV9kaXIudmFsdWVzKCkgfCBsaXN0IHwgZmlyc3QgfX0KICAgIHRyYWluX2xhYmVsX2RhdGFfcm9vdDoge3sgZGF0YV9yb290ICsgdHJhaW5fbGFiZWxzX2RpciB9fQogICAgdmFsX2RhdGFfcm9vdDoge3sgZGF0YV9yb290IH19e3sgdmFsX2RhdGFfZGlyLnZhbHVlcygpIHwgbGlzdCB8IGZpcnN0IH19CiAgICB2YWxfbGFiZWxfZGF0YV9yb290OiB7eyBkYXRhX3Jvb3QgKyB2YWxfbGFiZWxzX2RpciB9fQogICAgdGVzdF9kYXRhX3Jvb3Q6IHt7IGRhdGFfcm9vdCB9fXt7IHRlc3RfZGF0YV9kaXIudmFsdWVzKCkgfCBsaXN0IHwgZmlyc3QgfX0KICAgIHRlc3RfbGFiZWxfZGF0YV9yb290OiB7eyBkYXRhX3Jvb3QgKyB0ZXN0X2xhYmVsc19kaXIgfX0KICAgIHslIGlmIHRyYWluX3NwbGl0X3BhdGggLSV9CiAgICB0cmFpbl9zcGxpdDoge3sgZGF0YV9yb290ICsgdHJhaW5fc3BsaXRfcGF0aCB9fQogICAgeyUgZW5kaWYgLSV9CiAgICB7JSBpZiB0ZXN0X3NwbGl0X3BhdGggLSV9CiAgICB0ZXN0X3NwbGl0OiB7eyBkYXRhX3Jvb3QgKyB0ZXN0X3NwbGl0X3BhdGggfX0KICAgIHslIGVuZGlmIC0lfQogICAgeyUgaWYgdmFsX3NwbGl0X3BhdGggLSV9CiAgICB2YWxfc3BsaXQ6IHt7IGRhdGFfcm9vdCArIHZhbF9zcGxpdF9wYXRoIH19CiAgICB7JSBlbmRpZiAtJX0KICAgIHslIGlmIGltZ19zdWZmaXggLSV9CiAgICBpbWdfZ3JlcDogIHt7IGltZ19zdWZmaXgudmFsdWVzKCkgfCBsaXN0IHwgZmlyc3QgfCB0b2pzb24gfX0KICAgIHslIGVuZGlmIC0lfQogICAgeyUgaWYgc2VnX21hcF9zdWZmaXggLSV9CiAgICBsYWJlbF9ncmVwOiAie3sgc2VnX21hcF9zdWZmaXggfX0iCiAgICB7JSBlbmRpZiAtJX0KICAgIG1lYW5zOiAKICAgICAge3sgbm9ybV9tZWFucy52YWx1ZXMoKSB8IGxpc3QgfCBmaXJzdHwgdG9feWFtbCB8IGluZGVudCg2KSB9fQogICAgc3RkczogCiAgICAgIHt7IG5vcm1fc3Rkcy52YWx1ZXMoKSB8IGxpc3QgfCBmaXJzdCB8IHRvX3lhbWwgfCBpbmRlbnQoNikgfX0KICAgIG51bV9jbGFzc2VzOiB7eyBjbGFzc2VzfGxlbmd0aCB9fQogICAgeyUgaWYgZGF0YVsiZXhwYW5kX3RlbXBvcmFsX2RpbWVuc2lvbiJdIGlzIG5vdCBub25lIC0lfQogICAgZXhwYW5kX3RlbXBvcmFsX2RpbWVuc2lvbjogZGF0YVsiZXhwYW5kX3RlbXBvcmFsX2RpbWVuc2lvbiJdCiAgICB7JSBlbmRpZiAtJX0KICAgIHslIGlmIGRhdGFbImRyb3BfbGFzdCJdIGlzIG5vdCBub25lIC0lfQogICAgZHJvcF9sYXN0OiBkYXRhWyJkcm9wX2xhc3QiXQogICAgeyUgZW5kaWYgLSV9CiAgICAjIC0tLS0gdHJhaW5fdHJhbnNmb3JtIGlmIC0tLS0KICAgIHslIGlmIGRhdGFbInRyYWluX3RyYW5zZm9ybSJdIC0lfQogICAgdHJhaW5fdHJhbnNmb3JtOgogICAgeyUgZm9yIHRyYW5zZm9ybSBpbiBkYXRhWyJ0cmFpbl90cmFuc2Zvcm0iXSAlfQogICAgLSBjbGFzc19wYXRoOiB0cmFzbnNmb3JtWyJjbGFzc19wYXRoIl0KICAgICAgaW5pdF9hcmdzOgogICAgICAgIHslIGlmIHRyYXNuc2Zvcm1bImhlaWdodCJdIGlzIG5vdCBub25lIC0lfQogICAgICAgIGhlaWdodDogdHJhc25zZm9ybVsiaGVpZ2h0Il0KICAgICAgICB7JSBlbmRpZiAtJX0KICAgICAgICB7JSBpZiB0cmFzbnNmb3JtWyJ3aWR0aCJdIGlzIG5vdCBub25lIC0lfQogICAgICAgIHdpZHRoOiB0cmFzbnNmb3JtWyJ3aWR0aCJdCiAgICAgICAgeyUgZW5kaWYgLSV9CiAgICAgICAgeyUgaWYgdHJhc25zZm9ybVsiYWx3YXlzX2FwcGx5Il0gaXMgbm90IG5vbmUgLSV9CiAgICAgICAgYWx3YXlzX2FwcGx5OiB0cmFzbnNmb3JtWyJhbHdheXNfYXBwbHkiXQogICAgICAgIHslIGVuZGlmIC0lfQogICAgICAgIHslIGlmIHRyYXNuc2Zvcm1bInRyYW5zcG9zZV9tYXNrIl0gaXMgbm90IG5vbmUgLSV9CiAgICAgICAgdHJhbnNwb3NlX21hc2s6IHRyYXNuc2Zvcm1bInRyYW5zcG9zZV9tYXNrIl0KICAgICAgICB7JSBlbmRpZiAtJX0KICAgICAgICB7JSBpZiB0cmFzbnNmb3JtWyJwIl0gaXMgbm90IG5vbmUgLSV9CiAgICAgICAgcDogdHJhc25zZm9ybVsicCJdCiAgICAgICAgeyUgZW5kaWYgLSV9CiAgICB7JSBlbmRmb3IgJX0KICAgIHslIGVuZGlmIC0lfQogICAgIyAtLS0tIHRyYWluX3RyYW5zZm9ybSBlbmRpZiAtLS0tCgogICAgIyBpZiBiYWNrYm9uZSBpcyBwcml0aHZpLUVPLXYyCiAgICB0ZXN0X3RyYW5zZm9ybToKICAgICAgLSBjbGFzc19wYXRoOiBUb1RlbnNvclYyCm1vZGVsOgogIGNsYXNzX3BhdGg6IHRlcnJhdG9yY2gudGFza3MuU2VtYW50aWNTZWdtZW50YXRpb25UYXNrCiAgaW5pdF9hcmdzOgogICAgbW9kZWxfYXJnczogCiAgICAgIGJhY2tib25lOiB7eyBwcmV0cmFpbmVkX21vZGVsX25hbWUgfX0gIyBjbGF5X3YxX2Jhc2UKICAgICAgYmFja2JvbmVfcHJldHJhaW5lZDogdHJ1ZSAKICAgICAgbnVtX2NsYXNzZXM6IHt7IGNsYXNzZXN8bGVuZ3RoIH19CiAgICAgIGJhY2tib25lX2ltZ19zaXplOiA1MTIKICAgICAgYmFja2JvbmVfYmFuZHM6CiAgICAgICAge3sgb3V0cHV0X2JhbmRzLnZhbHVlcygpIHwgbGlzdCB8IGZpcnN0IHwgdG9feWFtbCB8IGluZGVudCg4KSB9fQogICAgICBuZWNrczogCiAgICAgICAgLSBuYW1lOiBTZWxlY3RJbmRpY2VzCiAgICAgICAgICBpbmRpY2VzOiBbMiwgNSwgOCwgMTFdIAogICAgICAgIC0gbmFtZTogUmVzaGFwZVRva2Vuc1RvSW1hZ2UgCiAgICAgICAgLSBuYW1lOiBMZWFybmVkSW50ZXJwb2xhdGVUb1B5cmFtaWRhbAogICAgICBkZWNvZGVyOiB7eyBtb2RlbFsiZGVjb2RlX2hlYWQiXVsiZGVjb2RlciJdIH19CiAgICAgIHslIGlmICBtb2RlbFsiZGVjb2RlX2hlYWQiXVsiZGVjb2RlciJdID09ICJVcGVyTmV0RGVjb2RlciIgLSV9CiAgICAgIGRlY29kZXJfY2hhbm5lbHM6IDI1NgogICAgICB7JSBlbGlmICBtb2RlbFsiZGVjb2RlX2hlYWQiXVsiZGVjb2RlciJdID09ICJVTmV0RGVjb2RlciIgLSV9CiAgICAgICNUT0RPIHVzZXIgcHJvdmlkZWQgY2hhbm5lbHMKICAgICAgZGVjb2Rlcl9jaGFubmVsczogWzUxMiwgMjU2LCAxMjgsIDY0XQogICAgICB7JSBlbHNlICV9CiAgICAgIGRlY29kZXJfY2hhbm5lbHM6IHt7IG1vZGVsWyJkZWNvZGVfaGVhZCJdWyJjaGFubmVscyJdIH19CiAgICAgIHslIGVuZGlmIC0lfQogICAgICBoZWFkX2NoYW5uZWxfbGlzdDoKICAgICAgICB7eyBoZWFkX2NoYW5uZWxfbGlzdCB8IHRvX3lhbWwgfCBpbmRlbnQoMTApIH19CiAgICAgIGhlYWRfZHJvcG91dDogMC4xCiAgICAKICAgIG1vZGVsX2ZhY3Rvcnk6IEVuY29kZXJEZWNvZGVyRmFjdG9yeQogICAgbG9zczoge3sgbW9kZWxbImRlY29kZV9oZWFkIl1bImxvc3NfZGVjb2RlIl1bInR5cGUiXSB9fQogICAgcGxvdF9vbl92YWw6IHt7IHJ1bm5lclsicGxvdF9vbl92YWwiXSB9fQogICAgeyUgaWYgbW9kZWxbImF1eGlsaWFyeV9oZWFkIl0gLSV9CiAgICBhdXhfaGVhZHM6CiAgICAgIC0gbmFtZTogYXV4X2hlYWQKICAgICAgICBkZWNvZGVyOiB7eyBtb2RlbFsiYXV4aWxpYXJ5X2hlYWQiXVsiZGVjb2RlciJdIH19CiAgICAgICAgZGVjb2Rlcl9hcmdzOgogICAgICAgICAgZGVjb2Rlcl9jaGFubmVsczoge3sgbW9kZWxbImF1eGlsaWFyeV9oZWFkIl1bImNoYW5uZWxzIl0gfX0KICAgICAgICAgIGRlY29kZXJfaW5faW5kZXg6IHt7IG1vZGVsWyJhdXhpbGlhcnlfaGVhZCJdWyJpbl9pbmRleCJdIH19CiAgICAgICAgICBkZWNvZGVyX251bV9jb252czoge3sgbW9kZWxbImF1eGlsaWFyeV9oZWFkIl1bIm51bV9jb252cyJdIH19CiAgICAgICAgICBoZWFkX2Ryb3BvdXQ6ICB7eyBtb2RlbFsiYXV4aWxpYXJ5X2hlYWQiXVsiZHJvcG91dCJdIH19CiAgICAgICAgICAjIGhlYWRfY2hhbm5lbF9saXN0OgogICAgICAgICAgIyAgIC0gNjQKICAgIGF1eF9sb3NzOgogICAgICBhdXhfaGVhZDoge3sgbW9kZWxbImF1eGlsaWFyeV9oZWFkIl1bImxvc3NfZGVjb2RlIl1bImxvc3Nfd2VpZ2h0Il0gfX0KICAgIHslIGVuZGlmIC0lfQogICAgaWdub3JlX2luZGV4OiB7eyBpZ25vcmVfaW5kZXggfX0KICAgIGZyZWV6ZV9iYWNrYm9uZToge3sgbW9kZWxbImZyb3plbl9iYWNrYm9uZSJdIHwgbG93ZXIgfX0KICAgIGZyZWV6ZV9kZWNvZGVyOiBmYWxzZQoKICAgICMgLS0tLSBvcHRpbWl6ZXIgc3RhcnQgLS0tLQogICAgeyUgaWYgbW9kZWxbIm9wdGltaXplciJdIC0lfQogICAgb3B0aW1pemVyOiB7eyBtb2RlbFsib3B0aW1pemVyIl1bInR5cGUiXSB9fQogICAgbHI6IHt7IG1vZGVsWyJvcHRpbWl6ZXIiXVsibHIiXSB8IGZsb2F0IH19CiAgICB7JSBlbmRpZiAtJX0KICAgICMgLS0tLSBvcHRpbWl6ZXIgZW5kIC0tLS0KICAgIHslIGlmIG1vZGVsWyJ0aWxlZF9pbmZlcmVuY2VfcGFyYW1ldGVycyJdICV9CiAgICB0aWxlZF9pbmZlcmVuY2VfcGFyYW1ldGVyczogCiAgICAgIGhfY3JvcDoge3sgbW9kZWxbInRpbGVkX2luZmVyZW5jZV9wYXJhbWV0ZXJzIl1bImhfY3JvcCJdIHwgaW50fX0KICAgICAgaF9zdHJpZGU6IHt7IG1vZGVsWyJ0aWxlZF9pbmZlcmVuY2VfcGFyYW1ldGVycyJdWyJoX3N0cmlkZSJdIHwgaW50IH19CiAgICAgIHdfY3JvcDoge3sgbW9kZWxbInRpbGVkX2luZmVyZW5jZV9wYXJhbWV0ZXJzIl1bIndfY3JvcCJdIHwgaW50fX0KICAgICAgd19zdHJpZGU6IHt7IG1vZGVsWyJ0aWxlZF9pbmZlcmVuY2VfcGFyYW1ldGVycyJdWyJ3X3N0cmlkZSJdIHwgaW50IH19CiAgICAgIGF2ZXJhZ2VfcGF0Y2hlczoge3sgbW9kZWxbInRpbGVkX2luZmVyZW5jZV9wYXJhbWV0ZXJzIl1bImF2ZXJhZ2VfcGF0Y2hlcyJdIH19CiAgICB7JSBlbHNlICV9CiAgICAjIFRvRG86IFJlbW92ZSB0aGUgdGlsZWRfaW5mZXJlbmNlIGlmIHVzZXIgbm90IHByb3ZpZGVkLiAKICAgIHRpbGVkX2luZmVyZW5jZV9wYXJhbWV0ZXJzOiAKICAgICAgaF9jcm9wOiA1MTIKICAgICAgIyBzdHJpZGUgbG9naWMgPSB3b3VsZCBiZSBoX2Nyb3AgLSBoX2Nyb3AgKiAwLjEyNQogICAgICBoX3N0cmlkZTogNDQ4CiAgICAgIHdfY3JvcDogNTEyCiAgICAgICMgc3RyaWRlIGxvZ2ljID0gd291bGQgYmUgd19jcm9wIC0gd19jcm9wICogMC4xMjUKICAgICAgd19zdHJpZGU6IDQ0OAogICAgICBhdmVyYWdlX3BhdGNoZXM6IHRydWUKICAgIHslIGVuZGlmICV9Cm9wdGltaXplcjoKICBjbGFzc19wYXRoOiB7eyAndG9yY2gub3B0aW0uJyArIG9wdGltaXplclsidHlwZSJdIH19CiAgaW5pdF9hcmdzOgogICAgIyAtLS0tIE9wdGltaXplciBzdGFydCBpZiAtLS0tCiAgICB7JSBpZiBvcHRpbWl6ZXJbImxyIl0gLSV9CiAgICBscjoge3sgb3B0aW1pemVyWyJsciJdIHwgZmxvYXQgfX0KICAgIHslIGVsc2UgJX0KICAgIGxyOiAxLmUtNAogICAgeyUgZW5kaWYgLSV9CiAgICB7JSBpZiBvcHRpbWl6ZXJbIndlaWdodF9kZWNheSJdIC0lfQogICAgd2VpZ2h0X2RlY2F5OiB7eyBvcHRpbWl6ZXJbIndlaWdodF9kZWNheSJdIH19CiAgICB7JSBlbHNlICV9CiAgICB3ZWlnaHRfZGVjYXk6IDAuMDUKICAgIHslIGVuZGlmIC0lfQogICAgIyAtLS0tIE9wdGltaXplciBzdG9wIGlmIC0tLS0KbHJfc2NoZWR1bGVyOgogIGNsYXNzX3BhdGg6IFJlZHVjZUxST25QbGF0ZWF1CiAgaW5pdF9hcmdzOgogICAgbW9uaXRvcjogdmFsL2xvc3MK"
}