{
    "name": "Regression",
    "description": "Generic template for v1 & v2 models: Regression",
    "purpose": "Regression",
    "model_params": {
        "$uri": "https://ibm.com/watsonx.ai.geospatial.finetune.regression.json",
        "type": "object",
        "title": "Finetune",
        "$schema": "https://json-schema.org/draft/2020-12/schema",
        "properties": {
            "data": {
            "type": "object",
            "default": {
                "batch_size": 4,
                "constant_multiply": 1,
                "workers_per_gpu": 2
            },
            "properties": {
                "batch_size": {
                "type": "int",
                "default": 4,
                "description": "Batch size",
                "studio_name": "Batch size"
                },
                "constant_multiply": {
                "type": "float",
                "default": 1,
                "description": "Constant Scale",
                "studio_name": "Constant Scale"
                },
                "workers_per_gpu": {
                "studio_name": "Workers per GPU",
                "description": "Workers per GPU",
                "type": "int",
                "default": 2
                }
            },
            "studio_name": "Data loading"
            },
            "model": {
            "type": "object",
            "default": {
                "decode_head": {
                "channels": 256,
                "num_convs": 4,
                "decoder": "UNetDecoder",
                "loss_decode": {
                    "type": "RMSELoss",
                    "avg_non_ignore": true
                }
                },
                "frozen_backbone": false,
                "tiled_inference_parameters": {
                "h_crop": 224,
                "h_stride": 196,
                "w_crop": 224,
                "w_stride": 196,
                "average_patches": false
                }
            },
            "properties": {
                "decode_head": {
                "type": "object",
                "default": {
                    "channels": 256,
                    "num_convs": 4,
                    "decoder": "UperNetDecoder",
                    "loss_decode": {
                    "type": "RMSELoss",
                    "avg_non_ignore": true
                    }
                },
                "properties": {
                    "channels": {
                    "type": "int",
                    "default": 256,
                    "description": "Channels at each block of the decode head, except the final one",
                    "studio_name": "Channels"
                    },
                    "num_convs": {
                    "type": "int",
                    "default": 4,
                    "description": "Number of convolutional blocks in the head (except the final one)",
                    "studio_name": "Blocks"
                    },
                    "decoder": {
                    "enum": [
                        "UperNetDecoder",
                        "UNetDecoder"
                    ],
                    "type": "string",
                    "default": "Fixed",
                    "description": "Decoder type",
                    "studio_name": "Decoder type"
                    },
                    "loss_decode": {
                    "type": "object",
                    "properties": {
                        "type": {
                        "enum": [
                            "MSELoss",
                            "RMSELoss",
                            "MeanAbsoluteError"
                        ],
                        "type": "string",
                        "default": "RMSELoss",
                        "description": "Type of loss function",
                        "studio_name": "Loss function"
                        },
                        "avg_non_ignore": {
                        "type": "bool",
                        "default": true,
                        "description": "The loss is only averaged over non-ignored targets (ignored targets are usually where labels are missing in the dataset) if this is True"
                        }
                    },
                    "description": "Loss function to be used",
                    "studio_name": "Loss"
                    }
                },
                "description": "Architecture of the decode head",
                "studio_name": "Head"
                },
                "auxiliary_head": {
                "type": "object",
                "default": {},
                "properties": {
                    "decoder": {
                    "type": "string",
                    "default": "FCNDecoder",
                    "description": "Decoder function to use",
                    "studio_name": "Decoder"
                    },
                    "channels": {
                    "type": "int",
                    "default": 256,
                    "description": "Channels at each block of the decode head, except the final one",
                    "studio_name": "Channels"
                    },
                    "num_convs": {
                    "type": "int",
                    "default": 2,
                    "description": "Number of convolutional blocks in the head (except the final one)",
                    "studio_name": "Blocks"
                    },
                    "loss_decode": {
                    "type": "object",
                    "properties": {
                        "type": {
                        "enum": [
                            "RMSELoss"
                        ],
                        "type": "string",
                        "default": "RMSELoss",
                        "description": "Type of loss function",
                        "studio_name": "Loss function"
                        },
                        "loss_weight": {
                        "type": "float",
                        "default": 1,
                        "description": "Multiplicative weight of the loss of the auxiliary head in the loss. The loss is calculated as aux_head_weight * aux_head_loss + decode_head_loss",
                        "studio_name": "Loss weight"
                        },
                        "avg_non_ignore": {
                        "type": "bool",
                        "default": true,
                        "description": "The loss is only averaged over non-ignored targets (ignored targets are usually where labels are missing in the dataset) if this is True"
                        }
                    },
                    "description": "Loss function to be used",
                    "studio_name": "Loss"
                    }
                },
                "description": "Architecture of the auxiliary head"
                },
                "frozen_backbone": {
                "type": "bool",
                "default": false,
                "description": "Freeze the weights of the backbone when set to True",
                "studio_name": "Freeze backbone"
                },
                "tiled_inference_parameters": {
                "type": "object",
                "default": {
                    "h_crop": 224,
                    "h_stride": 196,
                    "w_crop": 224,
                    "w_stride": 196,
                    "average_patches": false
                },
                "properties": {
                    "h_crop": {
                    "type": "int",
                    "default": 224,
                    "description": "h_crop values for tilling images",
                    "studio_name": "h_crop"
                    },
                    "h_stride": {
                    "type": "int",
                    "default": 196,
                    "description": "h_stride values for tilling images",
                    "studio_name": "h_stride"
                    },
                    "w_crop": {
                    "type": "int",
                    "default": 224,
                    "description": "w_crop values for tilling images",
                    "studio_name": "w_crop"
                    },
                    "w_stride": {
                    "type": "int",
                    "default": 196,
                    "description": "w_stride values for tilling images",
                    "studio_name": "w_stride"
                    },
                    "average_patches": {
                    "type": "bool",
                    "default": false,
                    "description": "Whether to use average_patches",
                    "studio_name": "average_patches"
                    }
                }
                }
            },
            "description": "Model architecture definition",
            "studio_name": "Architecture"
            },
            "runner": {
            "type": "object",
            "default": {
                "max_epochs": 10,
                "early_stopping_patience": 20,
                "early_stopping_monitor": "val/loss"
            },
            "properties": {
                "max_epochs": {
                "type": "int",
                "default": 10,
                "description": "Training epochs",
                "studio_name": "Training epochs"
                },
                "early_stopping_patience": {
                "type": "int",
                "default": 20,
                "description": "Early stopping patience",
                "studio_name": "Early stopping patience"
                },
                "early_stopping_monitor": {
                "type": "string",
                "default": "val/loss",
                "description": "Monitoring value to determine early stopping",
                "studio_name": "Early stopping monitor"
                }
            },
            "studio_name": "Runner"
            },
            "lr_config": {
            "type": "object",
            "default": {
                "policy": "Fixed"
            },
            "required": [
                "policy"
            ],
            "properties": {
                "policy": {
                "enum": [
                    "Fixed",
                    "CosineAnnealing"
                ],
                "type": "string",
                "default": "Fixed",
                "description": "Policy type",
                "studio_name": "Policy type"
                },
                "warmup_iters": {
                "type": "int",
                "default": 0,
                "description": "LR warmup iterations. Valid for some policies",
                "studio_name": "Learning rate warmup iterations"
                },
                "warmup_ratio": {
                "type": "float",
                "default": 1,
                "description": "Initial lr at warmup will be learning_rate * warmup_ratio",
                "studio_name": "LR warmup initialization ratio"
                }
            },
            "description": "Learning rate policy",
            "studio_name": "Learning rate policy"
            },
            "optimizer": {
            "type": "object",
            "default": {
                "lr": 0.00031406904191973693,
                "type": "Adam"
            },
            "properties": {
                "lr": {
                "type": "float",
                "default": 0.00031406904191973693,
                "description": "Learning rate",
                "studio_name": "Learning rate"
                },
                "type": {
                "enum": [
                    "Adam",
                    "SGD",
                    "AdamW",
                    "RMSProp"
                ],
                "default": "Adam",
                "description": "Optimizer to be used",
                "studio_name": "Optimizer type"
                },
                "weight_decay": {
                "type": "float",
                "default": 0,
                "description": "L2 weight regularization (weight decay)",
                "studio_name": "L2 regularization weight"
                }
            },
            "description": "Optimizer",
            "studio_name": "Optimizer"
            },
            "dataset_id": {
            "type": "string",
            "description": "ID of dataset to use for this finetuning",
            "studio_name": "Dataset"
            },
            "evaluation": {
            "type": "object",
            "default": {
                "interval": 1
            },
            "properties": {
                "interval": {
                "type": "int",
                "default": 1,
                "description": "Frequency of epochs with which to perform validation",
                "studio_name": "Epoch interval"
                }
            },
            "studio_name": "Validation"
            },
            "backbone_model_id": {
            "type": "string",
            "description": "ID of the pretrained backbone"
            }
        },
        "description": "A request sent to the finetuning service to start a finetune task for regression"
    },
    "extra_info": {
        "runtime_image": "us.icr.io/gfmaas/geostudio-ft-deploy:feat-update_tt_version-138",
        "model_category": "prithvi",
        "model_framework": "terratorch-v2"
    },
    "content": "IyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwojIExpY2Vuc2VkIE1hdGVyaWFscyAtIFByb3BlcnR5IG9mIElCTQojICJSZXN0cmljdGVkIE1hdGVyaWFscyBvZiBJQk0iCiMgQ29weXJpZ2h0IElCTSBDb3JwLiAyMDI1IEFMTCBSSUdIVFMgUkVTRVJWRUQKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwoKCiMgbGlnaHRuaW5nLnB5dG9yY2g9PTIuMS4xCnNlZWRfZXZlcnl0aGluZzogMAp0cmFpbmVyOgogIGFjY2VsZXJhdG9yOiBhdXRvCiAgc3RyYXRlZ3k6IGF1dG8KICBkZXZpY2VzOiBhdXRvCiAgbnVtX25vZGVzOiAxCiAgcHJlY2lzaW9uOiAxNi1taXhlZAogIGxvZ2dlcjoKICAgIGNsYXNzX3BhdGg6IGxpZ2h0bmluZy5weXRvcmNoLmxvZ2dlcnMubWxmbG93Lk1MRmxvd0xvZ2dlcgogICAgaW5pdF9hcmdzOgogICAgICBleHBlcmltZW50X25hbWU6IHt7IHR1bmVfaWQgfX0gIyBGdXR1cmUgdmVyc2lvbiwgY2huYWdlIHRoaXMgdG8gdXNlciAvIGVtYWlsCiAgICAgIHJ1bl9uYW1lOiAiVHJhaW4iICAgICMgRnV0dXJlIHZlcnNpb24sIGNobmFnZSB0aGlzIHRvIHR1bmVfaWQKICAgICAgdHJhY2tpbmdfdXJpOiB7eyBtbGZsb3dfdHJhY2tpbmdfdXJsIH19CiAgICAgIHNhdmVfZGlyOiB7eyBtb3VudF9yb290ICsgJ3R1bmUtdGFza3MvJyArIHR1bmVfaWQgKyAnL21sZmxvdycgfX0KICAgICAgeyUgaWYgbWxmbG93X3RhZ3MgLSV9CiAgICAgIHRhZ3M6CiAgICAgICAgeyUgZm9yIGtleSwgdmFsdWUgaW4gbWxmbG93X3RhZ3MuaXRlbXMoKSAtJX0KICAgICAgICB7eyBrZXkgfX06IHt7IHZhbHVlIH19CiAgICAgICAgeyUgZW5kZm9yICV9CiAgICAgIHslLSBlbmRpZiAlfSAgICAgICAKICBjYWxsYmFja3M6CiAgICAtIGNsYXNzX3BhdGg6IFJpY2hQcm9ncmVzc0JhcgogICAgLSBjbGFzc19wYXRoOiBMZWFybmluZ1JhdGVNb25pdG9yCiAgICAgIGluaXRfYXJnczoKICAgICAgICBsb2dnaW5nX2ludGVydmFsOiBlcG9jaAogICAgIyAtLS0tIEVhcmx5IHN0b3AgaWYgLS0tLQogICAgeyUgaWYgcnVubmVyWyJlYXJseV9zdG9wcGluZ19wYXRpZW5jZSJdIC0lfQogICAgLSBjbGFzc19wYXRoOiBFYXJseVN0b3BwaW5nCiAgICAgIGluaXRfYXJnczoKICAgICAgICBtb25pdG9yOiB7eyBydW5uZXJbImVhcmx5X3N0b3BwaW5nX21vbml0b3IiXX19CiAgICAgICAgcGF0aWVuY2U6IHt7IHJ1bm5lclsiZWFybHlfc3RvcHBpbmdfcGF0aWVuY2UiXSB9fQogICAgeyUtIGVuZGlmICV9CiAgICAgIyAtLS0tIEVhcmx5IHN0b3AgZW5kaWYgLS0tLQogICAgLSBjbGFzc19wYXRoOiBNb2RlbENoZWNrcG9pbnQKICAgICAgaW5pdF9hcmdzOgogICAgICAgIGRpcnBhdGg6IHt7IG1vdW50X3Jvb3QgKyAndHVuZS10YXNrcy8nICsgdHVuZV9pZCAgKyAnLycgfX0KICAgICAgICBtb2RlOiBtaW4KICAgICAgICBtb25pdG9yOiB2YWwvbG9zcwogICAgICAgIGZpbGVuYW1lOiB7eyAnYmVzdC1zdGF0ZV9kaWN0LXtlcG9jaDowMmR9JyB9fQogICAgICAgIHNhdmVfd2VpZ2h0c19vbmx5OiBUcnVlCiAgbWF4X2Vwb2Noczoge3sgcnVubmVyWyJtYXhfZXBvY2hzIl0gfX0KICBjaGVja192YWxfZXZlcnlfbl9lcG9jaDoge3sgZXZhbHVhdGlvblsiaW50ZXJ2YWwiXSB9fQogIGxvZ19ldmVyeV9uX3N0ZXBzOiA1MAogIGVuYWJsZV9jaGVja3BvaW50aW5nOiB0cnVlCiAgZGVmYXVsdF9yb290X2Rpcjoge3sgbW91bnRfcm9vdCArICd0dW5lLXRhc2tzLycgKyB0dW5lX2lkIH19CgpkYXRhOgogIGNsYXNzX3BhdGg6IHRlcnJhdG9yY2guZGF0YW1vZHVsZXMuR2VuZXJpY05vbkdlb1BpeGVsd2lzZVJlZ3Jlc3Npb25EYXRhTW9kdWxlCiAgaW5pdF9hcmdzOgogICAgYmF0Y2hfc2l6ZToge3sgZGF0YVsiYmF0Y2hfc2l6ZSJdIH19CiAgICBudW1fd29ya2Vyczoge3sgZGF0YVsid29ya2Vyc19wZXJfZ3B1Il0gfX0KICAgIG5vX2xhYmVsX3JlcGxhY2U6IHt7IGxhYmVsX25vZGF0YSB9fQogICAgbm9fZGF0YV9yZXBsYWNlOiB7eyBpbWFnZV9ub2RhdGFfcmVwbGFjZSB9fQogICAgY29uc3RhbnRfc2NhbGU6IHt7IGNvbnN0YW50X211bHRpcGx5IH19CiAgICBkYXRhc2V0X2JhbmRzOgogICAgICB7eyBiYW5kcy52YWx1ZXMoKSB8IGxpc3QgfCBmaXJzdCB8IHRvX3lhbWwgfCBpbmRlbnQoNikgfX0KICAgIG91dHB1dF9iYW5kczoKICAgICAge3sgb3V0cHV0X2JhbmRzLnZhbHVlcygpIHwgbGlzdCB8IGZpcnN0IHwgdG9feWFtbCB8IGluZGVudCg2KSB9fQogICAgcmdiX2luZGljZXM6CiAgICAgIHt7IHJnYl9iYW5kX2luZGljZXMgfCB0b195YW1sIHwgaW5kZW50KDYpIH19CiAgICB0cmFpbl9kYXRhX3Jvb3Q6IHt7IGRhdGFfcm9vdCB9fXt7IHRyYWluX2RhdGFfZGlyLnZhbHVlcygpIHwgbGlzdCB8IGZpcnN0IH19CiAgICB0cmFpbl9sYWJlbF9kYXRhX3Jvb3Q6IHt7IGRhdGFfcm9vdCArIHRyYWluX2xhYmVsc19kaXIgfX0KICAgIHZhbF9kYXRhX3Jvb3Q6IHt7IGRhdGFfcm9vdCB9fXt7IHZhbF9kYXRhX2Rpci52YWx1ZXMoKSB8IGxpc3QgfCBmaXJzdCB9fQogICAgdmFsX2xhYmVsX2RhdGFfcm9vdDoge3sgZGF0YV9yb290ICsgdmFsX2xhYmVsc19kaXIgfX0KICAgIHRlc3RfZGF0YV9yb290OiB7eyBkYXRhX3Jvb3QgfX17eyB0ZXN0X2RhdGFfZGlyLnZhbHVlcygpIHwgbGlzdCB8IGZpcnN0IH19CiAgICB0ZXN0X2xhYmVsX2RhdGFfcm9vdDoge3sgZGF0YV9yb290ICsgdGVzdF9sYWJlbHNfZGlyIH19CiAgICB7JSBpZiB0cmFpbl9zcGxpdF9wYXRoIC0lfQogICAgdHJhaW5fc3BsaXQ6IHt7IGRhdGFfcm9vdCArIHRyYWluX3NwbGl0X3BhdGggfX0KICAgIHslIGVuZGlmIC0lfQogICAgeyUgaWYgdGVzdF9zcGxpdF9wYXRoIC0lfQogICAgdGVzdF9zcGxpdDoge3sgZGF0YV9yb290ICsgdGVzdF9zcGxpdF9wYXRoIH19CiAgICB7JSBlbmRpZiAtJX0KICAgIHslIGlmIHZhbF9zcGxpdF9wYXRoIC0lfQogICAgdmFsX3NwbGl0OiB7eyBkYXRhX3Jvb3QgKyB2YWxfc3BsaXRfcGF0aCB9fQogICAgeyUgZW5kaWYgLSV9CiAgICB7JSBpZiBpbWdfc3VmZml4IC0lfQogICAgaW1nX2dyZXA6ICB7eyBpbWdfc3VmZml4LnZhbHVlcygpIHwgbGlzdCB8IGZpcnN0IHwgdG9qc29uIH19CiAgICB7JSBlbmRpZiAtJX0KICAgIHslIGlmIHNlZ19tYXBfc3VmZml4IC0lfQogICAgbGFiZWxfZ3JlcDogInt7IHNlZ19tYXBfc3VmZml4IH19IgogICAgeyUgZW5kaWYgLSV9CiAgICBtZWFuczogCiAgICAgIHt7IG5vcm1fbWVhbnMudmFsdWVzKCkgfCBsaXN0IHwgZmlyc3R8IHRvX3lhbWwgfCBpbmRlbnQoNikgfX0KICAgIHN0ZHM6IAogICAgICB7eyBub3JtX3N0ZHMudmFsdWVzKCkgfCBsaXN0IHwgZmlyc3QgfCB0b195YW1sIHwgaW5kZW50KDYpIH19CiAgICB7JSBpZiBkYXRhWyJleHBhbmRfdGVtcG9yYWxfZGltZW5zaW9uIl0gaXMgbm90IG5vbmUgLSV9CiAgICBleHBhbmRfdGVtcG9yYWxfZGltZW5zaW9uOiBkYXRhWyJleHBhbmRfdGVtcG9yYWxfZGltZW5zaW9uIl0KICAgIHslIGVuZGlmIC0lfQogICAgeyUgaWYgZGF0YVsiZHJvcF9sYXN0Il0gaXMgbm90IG5vbmUgLSV9CiAgICBkcm9wX2xhc3Q6IGRhdGFbImRyb3BfbGFzdCJdCiAgICB7JSBlbmRpZiAtJX0KICAgICMgLS0tLSB0cmFpbl90cmFuc2Zvcm0gaWYgLS0tLQogICAgeyUgaWYgZGF0YVsidHJhaW5fdHJhbnNmb3JtIl0gLSV9CiAgICB0cmFpbl90cmFuc2Zvcm06CiAgICB7JSBmb3IgdHJhbnNmb3JtIGluIGRhdGFbInRyYWluX3RyYW5zZm9ybSJdICV9CiAgICAtIGNsYXNzX3BhdGg6IHRyYXNuc2Zvcm1bImNsYXNzX3BhdGgiXQogICAgICBpbml0X2FyZ3M6CiAgICAgICAgeyUgaWYgdHJhc25zZm9ybVsiaGVpZ2h0Il0gaXMgbm90IG5vbmUgLSV9CiAgICAgICAgaGVpZ2h0OiB0cmFzbnNmb3JtWyJoZWlnaHQiXQogICAgICAgIHslIGVuZGlmIC0lfQogICAgICAgIHslIGlmIHRyYXNuc2Zvcm1bIndpZHRoIl0gaXMgbm90IG5vbmUgLSV9CiAgICAgICAgd2lkdGg6IHRyYXNuc2Zvcm1bIndpZHRoIl0KICAgICAgICB7JSBlbmRpZiAtJX0KICAgICAgICB7JSBpZiB0cmFzbnNmb3JtWyJhbHdheXNfYXBwbHkiXSBpcyBub3Qgbm9uZSAtJX0KICAgICAgICBhbHdheXNfYXBwbHk6IHRyYXNuc2Zvcm1bImFsd2F5c19hcHBseSJdCiAgICAgICAgeyUgZW5kaWYgLSV9CiAgICAgICAgeyUgaWYgdHJhc25zZm9ybVsidHJhbnNwb3NlX21hc2siXSBpcyBub3Qgbm9uZSAtJX0KICAgICAgICB0cmFuc3Bvc2VfbWFzazogdHJhc25zZm9ybVsidHJhbnNwb3NlX21hc2siXQogICAgICAgIHslIGVuZGlmIC0lfQogICAgICAgIHslIGlmIHRyYXNuc2Zvcm1bInAiXSBpcyBub3Qgbm9uZSAtJX0KICAgICAgICBwOiB0cmFzbnNmb3JtWyJwIl0KICAgICAgICB7JSBlbmRpZiAtJX0KICAgIHslIGVuZGZvciAlfQogICAgeyUgZW5kaWYgLSV9CiAgICAjIC0tLS0gdHJhaW5fdHJhbnNmb3JtIGVuZGlmIC0tLS0KCiAgICAjIGlmIGJhY2tib25lIGlzIHByaXRodmktRU8tdjIKICAgIHRlc3RfdHJhbnNmb3JtOgogICAgICAtIGNsYXNzX3BhdGg6IFRvVGVuc29yVjIKbW9kZWw6CiAgY2xhc3NfcGF0aDogdGVycmF0b3JjaC50YXNrcy5QaXhlbHdpc2VSZWdyZXNzaW9uVGFzawogIGluaXRfYXJnczoKICAgIG1vZGVsX2FyZ3M6IAogICAgICB7JS0gaWYgcHJldHJhaW5lZF9tb2RlbF9uYW1lID09ICJwcml0aHZpX2VvX3YxXzEwMCIgb3IgcHJldHJhaW5lZF9tb2RlbF9uYW1lID09ICJwcml0aHZpX2VvX3YyXzMwMCIgb3IgcHJldHJhaW5lZF9tb2RlbF9uYW1lID09ICJwcml0aHZpX2VvX3YyXzMwMF90bCIgb3IgcHJldHJhaW5lZF9tb2RlbF9uYW1lID09ICJwcml0aHZpX2VvX3YyXzYwMCIgb3IgcHJldHJhaW5lZF9tb2RlbF9uYW1lID09ICJwcml0aHZpX2VvX3YyXzYwMF90bCIgJX0KICAgICAgYmFja2JvbmVfcHJldHJhaW5lZDogdHJ1ZSAKICAgICAgYmFja2JvbmU6IHt7IHByZXRyYWluZWRfbW9kZWxfbmFtZSB9fQogICAgICBiYWNrYm9uZV9ja3B0X3BhdGg6IHt7IHByZXRyYWluZWRfd2VpZ2h0c19wYXRoIH19IAogICAgICBiYWNrYm9uZV9kcm9wX3BhdGg6IDAuMSAKICAgICAgYmFja2JvbmVfYmFuZHM6CiAgICAgICAge3sgb3V0cHV0X2JhbmRzLnZhbHVlcygpIHwgbGlzdCB8IGZpcnN0IHwgdG9feWFtbCB8IGluZGVudCg4KSB9fQogICAgICBuZWNrczogCiAgICAgICAgLSBuYW1lOiBTZWxlY3RJbmRpY2VzCiAgICAgICAgICB7JS0gaWYgcHJldHJhaW5lZF9tb2RlbF9uYW1lID09ICJwcml0aHZpX2VvX3YxXzEwMCIgJX0KICAgICAgICAgIGluZGljZXM6IFsyLCA1LCA4LCAxMV0gIyAxMDBNIG1vZGVscwogICAgICAgICAgeyUtIGVsaWYgcHJldHJhaW5lZF9tb2RlbF9uYW1lID09ICJwcml0aHZpX2VvX3YyXzMwMCIgb3IgcHJldHJhaW5lZF9tb2RlbF9uYW1lID09ICJwcml0aHZpX2VvX3YyXzMwMF90bCIgJX0KICAgICAgICAgIGluZGljZXM6IFs1LCAxMSwgMTcsIDIzXSAgIyAzMDBNIG1vZGVscwogICAgICAgICAgeyUtIGVsaWYgcHJldHJhaW5lZF9tb2RlbF9uYW1lID09ICJwcml0aHZpX2VvX3YyXzYwMCIgb3IgcHJldHJhaW5lZF9tb2RlbF9uYW1lID09ICJwcml0aHZpX2VvX3YyXzYwMF90bCIgJX0KICAgICAgICAgIGluZGljZXM6IFs3LCAxNSwgMjMsIDMxXSAjIDYwME0gbW9kZWxzICAgIAogICAgICAgICAgeyUgZW5kaWYgJX0KICAgICAgICAtIG5hbWU6IFJlc2hhcGVUb2tlbnNUb0ltYWdlICMgcmVxdWlyZWQKICAgICAgICAtIG5hbWU6IExlYXJuZWRJbnRlcnBvbGF0ZVRvUHlyYW1pZGFsCiAgICAgIHslLSBlbHNlICV9CiAgICAgICMgT2xkIG1vZGVsIHZlcnNpb24gY29uZmlndXJhdGlvbnMKICAgICAgcHJldHJhaW5lZDogdHJ1ZQogICAgICBiYWNrYm9uZToge3sgcHJldHJhaW5lZF9tb2RlbF9uYW1lIH19CiAgICAgIGJhY2tib25lX3ByZXRyYWluZWRfY2ZnX292ZXJsYXk6CiAgICAgICAgZmlsZToge3sgcHJldHJhaW5lZF93ZWlnaHRzX3BhdGggfX0KICAgICAgIyBiYWNrYm9uZV90ZW1wb3JhbF9lbmNvZGluZzogdHJ1ZQogICAgICBiYWNrYm9uZV9kcm9wX3BhdGhfcmF0ZTogMC4zCiAgICAgIGJhY2tib25lX3dpbmRvd19zaXplOiA3CiAgICAgIG51bV9mcmFtZXM6IHt7IG51bV9mcmFtZXMgfX0KICAgICAgaGVhZF9maW5hbF9hY3Q6IHRvcmNoLm5uLlJlTFUKICAgICAgaGVhZF9sZWFybmVkX3Vwc2NhbGVfbGF5ZXJzOiAyCiAgICAgIGluX2NoYW5uZWxzOiB7eyBiYW5kcy52YWx1ZXMoKSB8IGxpc3QgfCBmaXJzdCB8IGxlbmd0aCB9fQogICAgICBoZWFkX2NoYW5uZWxfbGlzdDoKICAgICAgICB7eyBoZWFkX2NoYW5uZWxfbGlzdCB8IHRvX3lhbWwgfCBpbmRlbnQoMTApIH19CiAgICAgIGJhbmRzOgogICAgICAgIHt7IG91dHB1dF9iYW5kcy52YWx1ZXMoKSB8IGxpc3QgfCBmaXJzdCB8IHRvX3lhbWwgfCBpbmRlbnQoOCkgfX0KICAgICAgeyUgZW5kaWYgJX0gCiAgICAgIGRlY29kZXI6IHt7IG1vZGVsWyJkZWNvZGVfaGVhZCJdWyJkZWNvZGVyIl0gfX0KICAgICAgeyUgaWYgIG1vZGVsWyJkZWNvZGVfaGVhZCJdWyJkZWNvZGVyIl0gPT0gIlVwZXJOZXREZWNvZGVyIiAtJX0KICAgICAgZGVjb2Rlcl9jaGFubmVsczogMjU2CiAgICAgIHslIGVsaWYgIG1vZGVsWyJkZWNvZGVfaGVhZCJdWyJkZWNvZGVyIl0gPT0gIlVOZXREZWNvZGVyIiAtJX0KICAgICAgZGVjb2Rlcl9jaGFubmVsczogWzUxMiwgMjU2LCAxMjgsIDY0XQogICAgICB7JSBlbHNlICV9CiAgICAgIGRlY29kZXJfY2hhbm5lbHM6IHt7IG1vZGVsWyJkZWNvZGVfaGVhZCJdWyJjaGFubmVscyJdIH19CiAgICAgIHslIGVuZGlmIC0lfQogICAgICBoZWFkX2Ryb3BvdXQ6IDAuMQogICAgIyBNb2RlbCBmYWN0b3J5CiAgICB7JSBpZiBwcmV0cmFpbmVkX21vZGVsX25hbWUgPT0gInByaXRodmlfZW9fdjFfMTAwIiBvciBwcmV0cmFpbmVkX21vZGVsX25hbWUgPT0gInByaXRodmlfZW9fdjJfMzAwIiBvciBwcmV0cmFpbmVkX21vZGVsX25hbWUgPT0gInByaXRodmlfZW9fdjJfMzAwX3RsIiBvciBwcmV0cmFpbmVkX21vZGVsX25hbWUgPT0gInByaXRodmlfZW9fdjJfNjAwIiBvciBwcmV0cmFpbmVkX21vZGVsX25hbWUgPT0gInByaXRodmlfZW9fdjJfNjAwX3RsIiAtJX0KICAgIG1vZGVsX2ZhY3Rvcnk6IEVuY29kZXJEZWNvZGVyRmFjdG9yeQogICAgeyUtIGVsc2UgJX0KICAgIG1vZGVsX2ZhY3Rvcnk6IFByaXRodmlNb2RlbEZhY3RvcnkKICAgIHslIGVuZGlmICV9IAogICAgbG9zczoge3sgbW9kZWxbImRlY29kZV9oZWFkIl1bImxvc3NfZGVjb2RlIl1bInR5cGUiXSB9fQogICAgcGxvdF9vbl92YWw6IHt7IHJ1bm5lclsicGxvdF9vbl92YWwiXSB9fQogICAgeyUgaWYgbW9kZWxbImF1eGlsaWFyeV9oZWFkIl0gLSV9CiAgICBhdXhfaGVhZHM6CiAgICAgIC0gbmFtZTogYXV4X2hlYWQKICAgICAgICBkZWNvZGVyOiB7eyBtb2RlbFsiYXV4aWxpYXJ5X2hlYWQiXVsiZGVjb2RlciJdIH19CiAgICAgICAgZGVjb2Rlcl9hcmdzOgogICAgICAgICAgZGVjb2Rlcl9jaGFubmVsczoge3sgbW9kZWxbImF1eGlsaWFyeV9oZWFkIl1bImNoYW5uZWxzIl0gfX0KICAgICAgICAgIGRlY29kZXJfaW5faW5kZXg6IHt7IG1vZGVsWyJhdXhpbGlhcnlfaGVhZCJdWyJpbl9pbmRleCJdIH19CiAgICAgICAgICBkZWNvZGVyX251bV9jb252czoge3sgbW9kZWxbImF1eGlsaWFyeV9oZWFkIl1bIm51bV9jb252cyJdIH19CiAgICAgICAgICBoZWFkX2Ryb3BvdXQ6ICB7eyBtb2RlbFsiYXV4aWxpYXJ5X2hlYWQiXVsiZHJvcG91dCJdIH19CiAgICAgICAgICAjIGhlYWRfY2hhbm5lbF9saXN0OgogICAgICAgICAgIyAgIC0gNjQKICAgIGF1eF9sb3NzOgogICAgICBhdXhfaGVhZDoge3sgbW9kZWxbImF1eGlsaWFyeV9oZWFkIl1bImxvc3NfZGVjb2RlIl1bImxvc3Nfd2VpZ2h0Il0gfX0KICAgIHslIGVuZGlmIC0lfQogICAgaWdub3JlX2luZGV4OiB7eyBpZ25vcmVfaW5kZXggfX0KICAgIGZyZWV6ZV9iYWNrYm9uZToge3sgbW9kZWxbImZyb3plbl9iYWNrYm9uZSJdIHwgbG93ZXIgfX0KICAgIGZyZWV6ZV9kZWNvZGVyOiBmYWxzZQogICAgIyAtLS0tIG9wdGltaXplciBzdGFydCAtLS0tCiAgICB7JSBpZiBtb2RlbFsib3B0aW1pemVyIl0gLSV9CiAgICBvcHRpbWl6ZXI6IHt7IG1vZGVsWyJvcHRpbWl6ZXIiXVsidHlwZSJdIH19CiAgICBscjoge3sgbW9kZWxbIm9wdGltaXplciJdWyJsciJdIHwgZmxvYXQgfX0KICAgIHslIGVuZGlmIC0lfQogICAgIyAtLS0tIG9wdGltaXplciBlbmQgLS0tLQogICAgeyUgaWYgbW9kZWxbInRpbGVkX2luZmVyZW5jZV9wYXJhbWV0ZXJzIl0gJX0KICAgIHRpbGVkX2luZmVyZW5jZV9wYXJhbWV0ZXJzOiAKICAgICAgaF9jcm9wOiB7eyBtb2RlbFsidGlsZWRfaW5mZXJlbmNlX3BhcmFtZXRlcnMiXVsiaF9jcm9wIl0gfCBpbnR9fQogICAgICBoX3N0cmlkZToge3sgbW9kZWxbInRpbGVkX2luZmVyZW5jZV9wYXJhbWV0ZXJzIl1bImhfc3RyaWRlIl0gfCBpbnQgfX0KICAgICAgd19jcm9wOiB7eyBtb2RlbFsidGlsZWRfaW5mZXJlbmNlX3BhcmFtZXRlcnMiXVsid19jcm9wIl0gfCBpbnR9fQogICAgICB3X3N0cmlkZToge3sgbW9kZWxbInRpbGVkX2luZmVyZW5jZV9wYXJhbWV0ZXJzIl1bIndfc3RyaWRlIl0gfCBpbnQgfX0KICAgICAgYXZlcmFnZV9wYXRjaGVzOiB7eyBtb2RlbFsidGlsZWRfaW5mZXJlbmNlX3BhcmFtZXRlcnMiXVsiYXZlcmFnZV9wYXRjaGVzIl0gfX0KICAgIHslIGVsc2UgJX0KICAgIHRpbGVkX2luZmVyZW5jZV9wYXJhbWV0ZXJzOiAKICAgICAgaF9jcm9wOiA1MTIKICAgICAgIyBzdHJpZGUgbG9naWMgPSB3b3VsZCBiZSBoX2Nyb3AgLSBoX2Nyb3AgKiAwLjEyNQogICAgICBoX3N0cmlkZTogNDQ4CiAgICAgIHdfY3JvcDogNTEyCiAgICAgICMgc3RyaWRlIGxvZ2ljID0gd291bGQgYmUgd19jcm9wIC0gd19jcm9wICogMC4xMjUKICAgICAgd19zdHJpZGU6IDQ0OAogICAgICBhdmVyYWdlX3BhdGNoZXM6IHRydWUKICAgIHslIGVuZGlmICV9Cm9wdGltaXplcjoKICBjbGFzc19wYXRoOiB7eyAndG9yY2gub3B0aW0uJyArIG9wdGltaXplclsidHlwZSJdIH19CiAgaW5pdF9hcmdzOgogICAgIyAtLS0tIE9wdGltaXplciBzdGFydCBpZiAtLS0tCiAgICB7JSBpZiBvcHRpbWl6ZXJbImxyIl0gLSV9CiAgICBscjoge3sgb3B0aW1pemVyWyJsciJdIHwgZmxvYXQgfX0KICAgIHslIGVsc2UgJX0KICAgIGxyOiAxLmUtNAogICAgeyUgZW5kaWYgLSV9CiAgICB7JSBpZiBvcHRpbWl6ZXJbIndlaWdodF9kZWNheSJdIC0lfQogICAgd2VpZ2h0X2RlY2F5OiB7eyBvcHRpbWl6ZXJbIndlaWdodF9kZWNheSJdIH19CiAgICB7JSBlbHNlICV9CiAgICB3ZWlnaHRfZGVjYXk6IDAuMDUKICAgIHslIGVuZGlmIC0lfQogICAgIyAtLS0tIE9wdGltaXplciBzdG9wIGlmIC0tLS0KbHJfc2NoZWR1bGVyOgogIGNsYXNzX3BhdGg6IFJlZHVjZUxST25QbGF0ZWF1CiAgaW5pdF9hcmdzOgogICAgbW9uaXRvcjogdmFsL2xvc3MK"
}