{
    "name": "timm_resnet : Segmentation",
    "description": "Segmentation of the resnet backbone models",
    "purpose": "Segmentation",
    "model_params": {
        "$uri": "https://ibm.com/watsonx.ai.geospatial.finetune.segmentation.resnet.json",
        "type": "object",
        "title": "Finetune",
        "$schema": "https://json-schema.org/draft/2020-12/schema",
        "properties": {
            "data": {
            "type": "object",
            "default": {
                "batch_size": 4,
                "constant_multiply": 1,
                "workers_per_gpu": 2
            },
            "properties": {
                "batch_size": {
                "type": "int",
                "default": 4,
                "description": "Batch size",
                "studio_name": "Batch size"
                },
                "constant_multiply": {
                "type": "float",
                "default": 1,
                "description": "Constant Scale",
                "studio_name": "Constant Scale"
                },
                "workers_per_gpu": {
                "studio_name": "Workers per GPU",
                "description": "Workers per GPU",
                "type": "int",
                "default": 2
                }
            },
            "studio_name": "Data loading"
            },
            "model": {
            "type": "object",
            "default": {
                "decode_head": {
                "channels": 256,
                "num_convs": 4,
                "decoder": "UNetDecoder",
                "loss_decode": {
                    "type": "CrossEntropyLoss",
                    "avg_non_ignore": true
                }
                },
                "frozen_backbone": false,
                "tiled_inference_parameters": {
                "h_crop": 224,
                "h_stride": 196,
                "w_crop": 224,
                "w_stride": 196,
                "average_patches": true
                }
            },
            "properties": {
                "decode_head": {
                "type": "object",
                "default": {
                    "channels": 256,
                    "num_convs": 4,
                    "decoder": "UperNetDecoder",
                    "loss_decode": {
                    "type": "CrossEntropyLoss",
                    "avg_non_ignore": true
                    }
                },
                "properties": {
                    "channels": {
                    "type": "int",
                    "default": 256,
                    "description": "Channels at each block of the decode head, except the final one",
                    "studio_name": "Channels"
                    },
                    "num_convs": {
                    "type": "int",
                    "default": 4,
                    "description": "Number of convolutional blocks in the head (except the final one)",
                    "studio_name": "Blocks"
                    },
                    "decoder": {
                    "enum": [
                        "UperNetDecoder",
                        "UNetDecoder"
                    ],
                    "type": "string",
                    "default": "Fixed",
                    "description": "Decoder type",
                    "studio_name": "Decoder type"
                    },
                    "loss_decode": {
                    "type": "object",
                    "properties": {
                        "type": {
                        "enum": [
                            "CrossEntropyLoss"
                        ],
                        "type": "string",
                        "default": "CrossEntropyLoss",
                        "description": "Type of loss function",
                        "studio_name": "Loss function"
                        },
                        "avg_non_ignore": {
                        "type": "bool",
                        "default": true,
                        "description": "The loss is only averaged over non-ignored targets (ignored targets are usually where labels are missing in the dataset) if this is True"
                        }
                    },
                    "description": "Loss function to be used",
                    "studio_name": "Loss"
                    }
                },
                "description": "Architecture of the decode head",
                "studio_name": "Head"
                },
                "auxiliary_head": {
                "type": "object",
                "default": {},
                "properties": {
                    "decoder": {
                    "type": "string",
                    "default": "FCNDecoder",
                    "description": "Decoder function to use",
                    "studio_name": "Decoder"
                    },
                    "channels": {
                    "type": "int",
                    "default": 256,
                    "description": "Channels at each block of the decode head, except the final one",
                    "studio_name": "Channels"
                    },
                    "num_convs": {
                    "type": "int",
                    "default": 2,
                    "description": "Number of convolutional blocks in the head (except the final one)",
                    "studio_name": "Blocks"
                    },
                    "in_index": {
                    "type": "int",
                    "default": -1,
                    "description": "Index of the input list to take. Defaults to -1",
                    "studio_name": "In index"
                    },
                    "dropout": {
                    "type": "int",
                    "default": 0,
                    "description": "Dropout value to apply. Defaults to 0",
                    "studio_name": "Dropout"
                    },
                    "loss_decode": {
                    "type": "object",
                    "properties": {
                        "type": {
                        "enum": [
                            "CrossEntropyLoss"
                        ],
                        "type": "string",
                        "default": "CrossEntropyLoss",
                        "description": "Type of loss function",
                        "studio_name": "Loss function"
                        },
                        "loss_weight": {
                        "type": "float",
                        "default": 1,
                        "description": "Multiplicative weight of the loss of the auxiliary head in the loss. The loss is calculated as aux_head_weight * aux_head_loss + decode_head_loss",
                        "studio_name": "Loss weight"
                        },
                        "avg_non_ignore": {
                        "type": "bool",
                        "default": true,
                        "description": "The loss is only averaged over non-ignored targets (ignored targets are usually where labels are missing in the dataset) if this is True"
                        }
                    },
                    "description": "Loss function to be used",
                    "studio_name": "Loss"
                    }
                },
                "description": "Architecture of the auxiliary head"
                },
                "frozen_backbone": {
                "type": "bool",
                "default": false,
                "description": "Freeze the weights of the backbone when set to True",
                "studio_name": "Freeze backbone"
                },
                "tiled_inference_parameters": {
                "type": "object",
                "default": {
                    "h_crop": 224,
                    "h_stride": 196,
                    "w_crop": 224,
                    "w_stride": 196,
                    "average_patches": true
                },
                "properties": {
                    "h_crop": {
                    "type": "int",
                    "default": 224,
                    "description": "h_crop values for tilling images",
                    "studio_name": "h_crop"
                    },
                    "h_stride": {
                    "type": "int",
                    "default": 196,
                    "description": "h_stride values for tilling images",
                    "studio_name": "h_stride"
                    },
                    "w_crop": {
                    "type": "int",
                    "default": 224,
                    "description": "w_crop values for tilling images",
                    "studio_name": "w_crop"
                    },
                    "w_stride": {
                    "type": "int",
                    "default": 196,
                    "description": "w_stride values for tilling images",
                    "studio_name": "w_stride"
                    },
                    "average_patches": {
                    "type": "bool",
                    "default": true,
                    "description": "Whether to use average_patches",
                    "studio_name": "average_patches"
                    }
                }
                }
            },
            "description": "Model architecture definition",
            "studio_name": "Architecture"
            },
            "runner": {
            "type": "object",
            "default": {
                "max_epochs": 10,
                "early_stopping_patience": 20,
                "early_stopping_monitor": "val/loss"
            },
            "properties": {
                "max_epochs": {
                "type": "int",
                "default": 10,
                "description": "Training epochs",
                "studio_name": "Training epochs"
                },
                "early_stopping_patience": {
                "type": "int",
                "default": 20,
                "description": "Early stopping patience",
                "studio_name": "Early stopping patience"
                },
                "early_stopping_monitor": {
                "type": "string",
                "default": "val/loss",
                "description": "Monitoring value to determine early stopping",
                "studio_name": "Early stopping monitor"
                }
            },
            "studio_name": "Runner"
            },
            "lr_config": {
            "type": "object",
            "default": {
                "policy": "Fixed"
            },
            "required": [
                "policy"
            ],
            "properties": {
                "policy": {
                "enum": [
                    "Fixed",
                    "CosineAnnealing"
                ],
                "type": "string",
                "default": "Fixed",
                "description": "Policy type",
                "studio_name": "Policy type"
                },
                "warmup_iters": {
                "type": "int",
                "default": 0,
                "description": "LR warmup iterations. Valid for some policies",
                "studio_name": "Learning rate warmup iterations"
                },
                "warmup_ratio": {
                "type": "float",
                "default": 1,
                "description": "Initial lr at warmup will be learning_rate * warmup_ratio",
                "studio_name": "LR warmup initialization ratio"
                }
            },
            "description": "Learning rate policy",
            "studio_name": "Learning rate policy"
            },
            "optimizer": {
            "type": "object",
            "default": {
                "lr": 0.00006,
                "type": "Adam"
            },
            "properties": {
                "lr": {
                "type": "float",
                "default": 0.00006,
                "description": "Learning rate",
                "studio_name": "Learning rate"
                },
                "type": {
                "enum": [
                    "Adam",
                    "SGD",
                    "AdamW",
                    "RMSProp"
                ],
                "default": "Adam",
                "description": "Optimizer to be used",
                "studio_name": "Optimizer type"
                },
                "weight_decay": {
                "type": "float",
                "default": 0,
                "description": "L2 weight regularization (weight decay)",
                "studio_name": "L2 regularization weight"
                }
            },
            "description": "Optimizer",
            "studio_name": "Optimizer"
            },
            "dataset_id": {
            "type": "string",
            "description": "ID of dataset to use for this finetuning",
            "studio_name": "Dataset"
            },
            "evaluation": {
            "type": "object",
            "default": {
                "interval": 1
            },
            "properties": {
                "interval": {
                "type": "int",
                "default": 1,
                "description": "Frequency of epochs with which to perform validation",
                "studio_name": "Epoch interval"
                }
            },
            "studio_name": "Validation"
            },
            "backbone_model_id": {
            "type": "string",
            "description": "ID of the pretrained backbone"
            }
        },
        "description": "A request sent to the finetuning service to start a finetune task for resnet backbone segmentation"
    },
    "extra_info": {
        "runtime_image": "us.icr.io/gfmaas/geostudio-ft-deploy:feat-update_tt_version-142",
        "model_category": "resnet"
    },
    "content": "IyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwojIExpY2Vuc2VkIE1hdGVyaWFscyAtIFByb3BlcnR5IG9mIElCTQojICJSZXN0cmljdGVkIE1hdGVyaWFscyBvZiBJQk0iCiMgQ29weXJpZ2h0IElCTSBDb3JwLiAyMDI1IEFMTCBSSUdIVFMgUkVTRVJWRUQKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwoKCiMgbGlnaHRuaW5nLnB5dG9yY2g9PTIuMS4xCnNlZWRfZXZlcnl0aGluZzogMAp0cmFpbmVyOgogIGFjY2VsZXJhdG9yOiBhdXRvCiAgc3RyYXRlZ3k6IGF1dG8KICBkZXZpY2VzOiBhdXRvCiAgbnVtX25vZGVzOiAxCiAgcHJlY2lzaW9uOiAxNi1taXhlZAogIGxvZ2dlcjoKICAgIGNsYXNzX3BhdGg6IGxpZ2h0bmluZy5weXRvcmNoLmxvZ2dlcnMubWxmbG93Lk1MRmxvd0xvZ2dlcgogICAgaW5pdF9hcmdzOgogICAgICBleHBlcmltZW50X25hbWU6IHt7IHR1bmVfaWQgfX0gIyBGdXR1cmUgdmVyc2lvbiwgY2huYWdlIHRoaXMgdG8gdXNlciAvIGVtYWlsCiAgICAgIHJ1bl9uYW1lOiAiVHJhaW4iICAgICMgRnV0dXJlIHZlcnNpb24sIGNobmFnZSB0aGlzIHRvIHR1bmVfaWQKICAgICAgdHJhY2tpbmdfdXJpOiB7eyBtbGZsb3dfdHJhY2tpbmdfdXJsIH19CiAgICAgIHNhdmVfZGlyOiB7eyBtb3VudF9yb290ICsgJ3R1bmUtdGFza3MvJyArIHR1bmVfaWQgKyAnL21sZmxvdycgfX0KICAgICAgeyUgaWYgbWxmbG93X3RhZ3MgLSV9CiAgICAgIHRhZ3M6CiAgICAgICAgeyUgZm9yIGtleSwgdmFsdWUgaW4gbWxmbG93X3RhZ3MuaXRlbXMoKSAtJX0KICAgICAgICB7eyBrZXkgfX06IHt7IHZhbHVlIH19CiAgICAgICAgeyUgZW5kZm9yICV9CiAgICAgIHslLSBlbmRpZiAlfSAgICAgICAKICBjYWxsYmFja3M6CiAgICAtIGNsYXNzX3BhdGg6IFJpY2hQcm9ncmVzc0JhcgogICAgLSBjbGFzc19wYXRoOiBMZWFybmluZ1JhdGVNb25pdG9yCiAgICAgIGluaXRfYXJnczoKICAgICAgICBsb2dnaW5nX2ludGVydmFsOiBlcG9jaAogICAgIyAtLS0tIEVhcmx5IHN0b3AgaWYgLS0tLQogICAgeyUgaWYgcnVubmVyWyJlYXJseV9zdG9wcGluZ19wYXRpZW5jZSJdIC0lfQogICAgLSBjbGFzc19wYXRoOiBFYXJseVN0b3BwaW5nCiAgICAgIGluaXRfYXJnczoKICAgICAgICBtb25pdG9yOiB7eyBydW5uZXJbImVhcmx5X3N0b3BwaW5nX21vbml0b3IiXSB9fQogICAgICAgIHBhdGllbmNlOiB7eyBydW5uZXJbImVhcmx5X3N0b3BwaW5nX3BhdGllbmNlIl0gfX0KICAgIHslLSBlbmRpZiAlfQogICAgICMgLS0tLSBFYXJseSBzdG9wIGVuZGlmIC0tLS0KICAgIC0gY2xhc3NfcGF0aDogTW9kZWxDaGVja3BvaW50CiAgICAgIGluaXRfYXJnczoKICAgICAgICBkaXJwYXRoOiB7eyBtb3VudF9yb290ICsgJ3R1bmUtdGFza3MvJyArIHR1bmVfaWQgICsgJy8nIH19CiAgICAgICAgbW9kZTogbWluCiAgICAgICAgbW9uaXRvcjogdmFsL2xvc3MKICAgICAgICBmaWxlbmFtZToge3sgJ2Jlc3Qtc3RhdGVfZGljdC17ZXBvY2g6MDJkfScgfX0KICAgICAgICBzYXZlX3dlaWdodHNfb25seTogVHJ1ZQogICAgICAKICBtYXhfZXBvY2hzOiB7eyBydW5uZXJbIm1heF9lcG9jaHMiXSB9fQogIGNoZWNrX3ZhbF9ldmVyeV9uX2Vwb2NoOiB7eyBldmFsdWF0aW9uWyJpbnRlcnZhbCJdIH19CiAgbG9nX2V2ZXJ5X25fc3RlcHM6IDUwCiAgZW5hYmxlX2NoZWNrcG9pbnRpbmc6IHRydWUKICBkZWZhdWx0X3Jvb3RfZGlyOiB7eyBtb3VudF9yb290ICsgJ3R1bmUtdGFza3MvJyArIHR1bmVfaWQgfX0KCmRhdGE6CiAgY2xhc3NfcGF0aDogdGVycmF0b3JjaC5kYXRhbW9kdWxlcy5HZW5lcmljTm9uR2VvU2VnbWVudGF0aW9uRGF0YU1vZHVsZQogIGluaXRfYXJnczoKICAgIGJhdGNoX3NpemU6IHt7IGRhdGFbImJhdGNoX3NpemUiXSB9fQogICAgbnVtX3dvcmtlcnM6IHt7IGRhdGFbIndvcmtlcnNfcGVyX2dwdSJdIH19CiAgICBub19sYWJlbF9yZXBsYWNlOiB7eyBsYWJlbF9ub2RhdGEgfX0KICAgIG5vX2RhdGFfcmVwbGFjZToge3sgaW1hZ2Vfbm9kYXRhX3JlcGxhY2UgfX0KICAgIGNvbnN0YW50X3NjYWxlOiB7eyBjb25zdGFudF9tdWx0aXBseSB9fQogICAgZGF0YXNldF9iYW5kczoKICAgICAge3sgYmFuZHMudmFsdWVzKCkgfCBsaXN0IHwgZmlyc3QgfCB0b195YW1sIHwgaW5kZW50KDYpIH19CiAgICBvdXRwdXRfYmFuZHM6CiAgICAgIHt7IG91dHB1dF9iYW5kcy52YWx1ZXMoKSB8IGxpc3QgfCBmaXJzdCB8IHRvX3lhbWwgfCBpbmRlbnQoNikgfX0KICAgIHJnYl9pbmRpY2VzOgogICAgICB7eyByZ2JfYmFuZF9pbmRpY2VzIHwgdG9feWFtbCB8IGluZGVudCg2KSB9fQogICAgdHJhaW5fZGF0YV9yb290OiB7eyBkYXRhX3Jvb3QgfX17eyB0cmFpbl9kYXRhX2Rpci52YWx1ZXMoKSB8IGxpc3QgfCBmaXJzdCB9fQogICAgdHJhaW5fbGFiZWxfZGF0YV9yb290OiB7eyBkYXRhX3Jvb3QgKyB0cmFpbl9sYWJlbHNfZGlyIH19CiAgICB2YWxfZGF0YV9yb290OiB7eyBkYXRhX3Jvb3QgfX17eyB2YWxfZGF0YV9kaXIudmFsdWVzKCkgfCBsaXN0IHwgZmlyc3QgfX0KICAgIHZhbF9sYWJlbF9kYXRhX3Jvb3Q6IHt7IGRhdGFfcm9vdCArIHZhbF9sYWJlbHNfZGlyIH19CiAgICB0ZXN0X2RhdGFfcm9vdDoge3sgZGF0YV9yb290IH19e3sgdGVzdF9kYXRhX2Rpci52YWx1ZXMoKSB8IGxpc3QgfCBmaXJzdCB9fQogICAgdGVzdF9sYWJlbF9kYXRhX3Jvb3Q6IHt7IGRhdGFfcm9vdCArIHRlc3RfbGFiZWxzX2RpciB9fQogICAgeyUgaWYgdHJhaW5fc3BsaXRfcGF0aCAtJX0KICAgIHRyYWluX3NwbGl0OiB7eyBkYXRhX3Jvb3QgKyB0cmFpbl9zcGxpdF9wYXRoIH19CiAgICB7JSBlbmRpZiAtJX0KICAgIHslIGlmIHRlc3Rfc3BsaXRfcGF0aCAtJX0KICAgIHRlc3Rfc3BsaXQ6IHt7IGRhdGFfcm9vdCArIHRlc3Rfc3BsaXRfcGF0aCB9fQogICAgeyUgZW5kaWYgLSV9CiAgICB7JSBpZiB2YWxfc3BsaXRfcGF0aCAtJX0KICAgIHZhbF9zcGxpdDoge3sgZGF0YV9yb290ICsgdmFsX3NwbGl0X3BhdGggfX0KICAgIHslIGVuZGlmIC0lfQogICAgeyUgaWYgaW1nX3N1ZmZpeCAtJX0KICAgIGltZ19ncmVwOiAge3sgaW1nX3N1ZmZpeC52YWx1ZXMoKSB8IGxpc3QgfCBmaXJzdCB8IHRvanNvbiB9fQogICAgeyUgZW5kaWYgLSV9CiAgICB7JSBpZiBzZWdfbWFwX3N1ZmZpeCAtJX0KICAgIGxhYmVsX2dyZXA6ICJ7eyBzZWdfbWFwX3N1ZmZpeCB9fSIKICAgIHslIGVuZGlmIC0lfQogICAgbWVhbnM6IAogICAgICB7eyBub3JtX21lYW5zLnZhbHVlcygpIHwgbGlzdCB8IGZpcnN0fCB0b195YW1sIHwgaW5kZW50KDYpIH19CiAgICBzdGRzOiAKICAgICAge3sgbm9ybV9zdGRzLnZhbHVlcygpIHwgbGlzdCB8IGZpcnN0IHwgdG9feWFtbCB8IGluZGVudCg2KSB9fQogICAgbnVtX2NsYXNzZXM6IHt7IGNsYXNzZXN8bGVuZ3RoIH19CiAgICB7JSBpZiBkYXRhWyJleHBhbmRfdGVtcG9yYWxfZGltZW5zaW9uIl0gaXMgbm90IG5vbmUgLSV9CiAgICBleHBhbmRfdGVtcG9yYWxfZGltZW5zaW9uOiBkYXRhWyJleHBhbmRfdGVtcG9yYWxfZGltZW5zaW9uIl0KICAgIHslIGVuZGlmIC0lfQogICAgeyUgaWYgZGF0YVsiZHJvcF9sYXN0Il0gaXMgbm90IG5vbmUgLSV9CiAgICBkcm9wX2xhc3Q6IGRhdGFbImRyb3BfbGFzdCJdCiAgICB7JSBlbmRpZiAtJX0KICAgICMgLS0tLSB0cmFpbl90cmFuc2Zvcm0gaWYgLS0tLQogICAgeyUgaWYgZGF0YVsidHJhaW5fdHJhbnNmb3JtIl0gLSV9CiAgICB0cmFpbl90cmFuc2Zvcm06CiAgICB7JSBmb3IgdHJhbnNmb3JtIGluIGRhdGFbInRyYWluX3RyYW5zZm9ybSJdICV9CiAgICAtIGNsYXNzX3BhdGg6IHRyYXNuc2Zvcm1bImNsYXNzX3BhdGgiXQogICAgICBpbml0X2FyZ3M6CiAgICAgICAgeyUgaWYgdHJhc25zZm9ybVsiaGVpZ2h0Il0gaXMgbm90IG5vbmUgLSV9CiAgICAgICAgaGVpZ2h0OiB0cmFzbnNmb3JtWyJoZWlnaHQiXQogICAgICAgIHslIGVuZGlmIC0lfQogICAgICAgIHslIGlmIHRyYXNuc2Zvcm1bIndpZHRoIl0gaXMgbm90IG5vbmUgLSV9CiAgICAgICAgd2lkdGg6IHRyYXNuc2Zvcm1bIndpZHRoIl0KICAgICAgICB7JSBlbmRpZiAtJX0KICAgICAgICB7JSBpZiB0cmFzbnNmb3JtWyJhbHdheXNfYXBwbHkiXSBpcyBub3Qgbm9uZSAtJX0KICAgICAgICBhbHdheXNfYXBwbHk6IHRyYXNuc2Zvcm1bImFsd2F5c19hcHBseSJdCiAgICAgICAgeyUgZW5kaWYgLSV9CiAgICAgICAgeyUgaWYgdHJhc25zZm9ybVsidHJhbnNwb3NlX21hc2siXSBpcyBub3Qgbm9uZSAtJX0KICAgICAgICB0cmFuc3Bvc2VfbWFzazogdHJhc25zZm9ybVsidHJhbnNwb3NlX21hc2siXQogICAgICAgIHslIGVuZGlmIC0lfQogICAgICAgIHslIGlmIHRyYXNuc2Zvcm1bInAiXSBpcyBub3Qgbm9uZSAtJX0KICAgICAgICBwOiB0cmFzbnNmb3JtWyJwIl0KICAgICAgICB7JSBlbmRpZiAtJX0KICAgIHslIGVuZGZvciAlfQogICAgeyUgZW5kaWYgLSV9CiAgICAjIC0tLS0gdHJhaW5fdHJhbnNmb3JtIGVuZGlmIC0tLS0KCiAgICAjIGlmIGJhY2tib25lIGlzIHByaXRodmktRU8tdjIKICAgIHRlc3RfdHJhbnNmb3JtOgogICAgICAtIGNsYXNzX3BhdGg6IFRvVGVuc29yVjIKbW9kZWw6CiAgY2xhc3NfcGF0aDogdGVycmF0b3JjaC50YXNrcy5TZW1hbnRpY1NlZ21lbnRhdGlvblRhc2sKICBpbml0X2FyZ3M6CiAgICBtb2RlbF9hcmdzOiAKICAgICAgYmFja2JvbmU6IHt7IHByZXRyYWluZWRfbW9kZWxfbmFtZSB9fSAjIHRpbW1fcmVzbmV0MzQgLCB0aW1tX3Jlc25ldDE4ICwgdGltbV9yZXNuZXQ1MCAsIHRpbW1fcmVzbmV0MTAxICwgdGltbV9yZXNuZXQxNTIKICAgICAgYmFja2JvbmVfcHJldHJhaW5lZDogdHJ1ZSAKICAgICAgbnVtX2NsYXNzZXM6IHt7IGNsYXNzZXN8bGVuZ3RoIH19CiAgICAgIGJhY2tib25lX2luX2NoYW5zOiB7eyBvdXRwdXRfYmFuZHMudmFsdWVzKCkgfCBsaXN0IHwgZmlyc3QgfCBsZW5ndGggfX0gIyBUbyBiZSB1c2VkIHdpdGggUkdCIHdoZW4gcHJldHJhaW5lZCwgY2FuIGJlIG1vcmUgaWYgbm90IHJldHJhaW5lZAogICAgICBuZWNrczogCiAgICAgICAgLSBuYW1lOiBTZWxlY3RJbmRpY2VzCiAgICAgICAgICBpbmRpY2VzOiAgWzAsIDEsIDIsIDNdCiAgICAgIGRlY29kZXI6IHt7IG1vZGVsWyJkZWNvZGVfaGVhZCJdWyJkZWNvZGVyIl0gfX0KICAgICAgeyUgaWYgIG1vZGVsWyJkZWNvZGVfaGVhZCJdWyJkZWNvZGVyIl0gPT0gIlVwZXJOZXREZWNvZGVyIiAtJX0KICAgICAgZGVjb2Rlcl9jaGFubmVsczogMjU2CiAgICAgIHslIGVsaWYgIG1vZGVsWyJkZWNvZGVfaGVhZCJdWyJkZWNvZGVyIl0gPT0gIlVOZXREZWNvZGVyIiAtJX0KICAgICAgI1RPRE8gdXNlciBwcm92aWRlZCBjaGFubmVscwogICAgICBkZWNvZGVyX2NoYW5uZWxzOiBbNTEyLCAyNTYsIDEyOCwgNjRdCiAgICAgIHslIGVsc2UgJX0KICAgICAgZGVjb2Rlcl9jaGFubmVsczoge3sgbW9kZWxbImRlY29kZV9oZWFkIl1bImNoYW5uZWxzIl0gfX0KICAgICAgeyUgZW5kaWYgLSV9CiAgICAgIGhlYWRfY2hhbm5lbF9saXN0OgogICAgICAgIHt7IGhlYWRfY2hhbm5lbF9saXN0IHwgdG9feWFtbCB8IGluZGVudCgxMCkgfX0KICAgICAgaGVhZF9kcm9wb3V0OiAwLjEKICAgIAogICAgbW9kZWxfZmFjdG9yeTogRW5jb2RlckRlY29kZXJGYWN0b3J5CiAgICBsb3NzOiB7eyBtb2RlbFsiZGVjb2RlX2hlYWQiXVsibG9zc19kZWNvZGUiXVsidHlwZSJdIH19CiAgICBwbG90X29uX3ZhbDoge3sgcnVubmVyWyJwbG90X29uX3ZhbCJdIH19CiAgICB7JSBpZiBtb2RlbFsiYXV4aWxpYXJ5X2hlYWQiXSAtJX0KICAgIGF1eF9oZWFkczoKICAgICAgLSBuYW1lOiBhdXhfaGVhZAogICAgICAgIGRlY29kZXI6IHt7IG1vZGVsWyJhdXhpbGlhcnlfaGVhZCJdWyJkZWNvZGVyIl0gfX0KICAgICAgICBkZWNvZGVyX2FyZ3M6CiAgICAgICAgICBkZWNvZGVyX2NoYW5uZWxzOiB7eyBtb2RlbFsiYXV4aWxpYXJ5X2hlYWQiXVsiY2hhbm5lbHMiXSB9fQogICAgICAgICAgZGVjb2Rlcl9pbl9pbmRleDoge3sgbW9kZWxbImF1eGlsaWFyeV9oZWFkIl1bImluX2luZGV4Il0gfX0KICAgICAgICAgIGRlY29kZXJfbnVtX2NvbnZzOiB7eyBtb2RlbFsiYXV4aWxpYXJ5X2hlYWQiXVsibnVtX2NvbnZzIl0gfX0KICAgICAgICAgIGhlYWRfZHJvcG91dDogIHt7IG1vZGVsWyJhdXhpbGlhcnlfaGVhZCJdWyJkcm9wb3V0Il0gfX0KICAgICAgICAgICMgaGVhZF9jaGFubmVsX2xpc3Q6CiAgICAgICAgICAjICAgLSA2NAogICAgYXV4X2xvc3M6CiAgICAgIGF1eF9oZWFkOiB7eyBtb2RlbFsiYXV4aWxpYXJ5X2hlYWQiXVsibG9zc19kZWNvZGUiXVsibG9zc193ZWlnaHQiXSB9fQogICAgeyUgZW5kaWYgLSV9CiAgICBpZ25vcmVfaW5kZXg6IHt7IGlnbm9yZV9pbmRleCB9fQogICAgZnJlZXplX2JhY2tib25lOiB7eyBtb2RlbFsiZnJvemVuX2JhY2tib25lIl0gfCBsb3dlciB9fQogICAgZnJlZXplX2RlY29kZXI6IGZhbHNlCgogICAgIyAtLS0tIG9wdGltaXplciBzdGFydCAtLS0tCiAgICB7JSBpZiBtb2RlbFsib3B0aW1pemVyIl0gLSV9CiAgICBvcHRpbWl6ZXI6IHt7IG1vZGVsWyJvcHRpbWl6ZXIiXVsidHlwZSJdIH19CiAgICBscjoge3sgbW9kZWxbIm9wdGltaXplciJdWyJsciJdIHwgZmxvYXQgfX0KICAgIHslIGVuZGlmIC0lfQogICAgIyAtLS0tIG9wdGltaXplciBlbmQgLS0tLQogICAgeyUgaWYgbW9kZWxbInRpbGVkX2luZmVyZW5jZV9wYXJhbWV0ZXJzIl0gJX0KICAgIHRpbGVkX2luZmVyZW5jZV9wYXJhbWV0ZXJzOiAKICAgICAgaF9jcm9wOiB7eyBtb2RlbFsidGlsZWRfaW5mZXJlbmNlX3BhcmFtZXRlcnMiXVsiaF9jcm9wIl0gfCBpbnR9fQogICAgICBoX3N0cmlkZToge3sgbW9kZWxbInRpbGVkX2luZmVyZW5jZV9wYXJhbWV0ZXJzIl1bImhfc3RyaWRlIl0gfCBpbnQgfX0KICAgICAgd19jcm9wOiB7eyBtb2RlbFsidGlsZWRfaW5mZXJlbmNlX3BhcmFtZXRlcnMiXVsid19jcm9wIl0gfCBpbnR9fQogICAgICB3X3N0cmlkZToge3sgbW9kZWxbInRpbGVkX2luZmVyZW5jZV9wYXJhbWV0ZXJzIl1bIndfc3RyaWRlIl0gfCBpbnQgfX0KICAgICAgYXZlcmFnZV9wYXRjaGVzOiB7eyBtb2RlbFsidGlsZWRfaW5mZXJlbmNlX3BhcmFtZXRlcnMiXVsiYXZlcmFnZV9wYXRjaGVzIl0gfX0KICAgIHslIGVsc2UgJX0KICAgICMgVG9EbzogUmVtb3ZlIHRoZSB0aWxlZF9pbmZlcmVuY2UgaWYgdXNlciBub3QgcHJvdmlkZWQuIAogICAgdGlsZWRfaW5mZXJlbmNlX3BhcmFtZXRlcnM6IAogICAgICBoX2Nyb3A6IDUxMgogICAgICAjIHN0cmlkZSBsb2dpYyA9IHdvdWxkIGJlIGhfY3JvcCAtIGhfY3JvcCAqIDAuMTI1CiAgICAgIGhfc3RyaWRlOiA0NDgKICAgICAgd19jcm9wOiA1MTIKICAgICAgIyBzdHJpZGUgbG9naWMgPSB3b3VsZCBiZSB3X2Nyb3AgLSB3X2Nyb3AgKiAwLjEyNQogICAgICB3X3N0cmlkZTogNDQ4CiAgICAgIGF2ZXJhZ2VfcGF0Y2hlczogdHJ1ZQogICAgeyUgZW5kaWYgJX0Kb3B0aW1pemVyOgogIGNsYXNzX3BhdGg6IHt7ICd0b3JjaC5vcHRpbS4nICsgb3B0aW1pemVyWyJ0eXBlIl0gfX0KICBpbml0X2FyZ3M6CiAgICAjIC0tLS0gT3B0aW1pemVyIHN0YXJ0IGlmIC0tLS0KICAgIHslIGlmIG9wdGltaXplclsibHIiXSAtJX0KICAgIGxyOiB7eyBvcHRpbWl6ZXJbImxyIl0gfCBmbG9hdCB9fQogICAgeyUgZWxzZSAlfQogICAgbHI6IDEuZS00CiAgICB7JSBlbmRpZiAtJX0KICAgIHslIGlmIG9wdGltaXplclsid2VpZ2h0X2RlY2F5Il0gLSV9CiAgICB3ZWlnaHRfZGVjYXk6IHt7IG9wdGltaXplclsid2VpZ2h0X2RlY2F5Il0gfX0KICAgIHslIGVsc2UgJX0KICAgIHdlaWdodF9kZWNheTogMC4wNQogICAgeyUgZW5kaWYgLSV9CiAgICAjIC0tLS0gT3B0aW1pemVyIHN0b3AgaWYgLS0tLQpscl9zY2hlZHVsZXI6CiAgY2xhc3NfcGF0aDogUmVkdWNlTFJPblBsYXRlYXUKICBpbml0X2FyZ3M6CiAgICBtb25pdG9yOiB2YWwvbG9zcwo="
}